<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/jeremyfa/yaml.js#readme"

    >yamljs (v0.2.9)</a>
</h1>
<h4>Standalone JavaScript YAML 1.2 Parser & Encoder. Works under node.js and all major browsers. Also brings command line YAML/JSON conversion tools.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.yamljs">module yamljs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Dumper">
            function <span class="apidocSignatureSpan">yamljs.</span>Dumper
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Escaper">
            function <span class="apidocSignatureSpan">yamljs.</span>Escaper
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Inline">
            function <span class="apidocSignatureSpan">yamljs.</span>Inline
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Parser">
            function <span class="apidocSignatureSpan">yamljs.</span>Parser
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Pattern">
            function <span class="apidocSignatureSpan">yamljs.</span>Pattern
            <span class="apidocSignatureSpan">(rawRegex, modifiers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Unescaper">
            function <span class="apidocSignatureSpan">yamljs.</span>Unescaper
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Utils">
            function <span class="apidocSignatureSpan">yamljs.</span>Utils
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.dump">
            function <span class="apidocSignatureSpan">yamljs.</span>dump
            <span class="apidocSignatureSpan">(input, inline, indent, exceptionOnInvalidType, objectEncoder)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.load">
            function <span class="apidocSignatureSpan">yamljs.</span>load
            <span class="apidocSignatureSpan">(path, callback, exceptionOnInvalidType, objectDecoder)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.parse">
            function <span class="apidocSignatureSpan">yamljs.</span>parse
            <span class="apidocSignatureSpan">(input, exceptionOnInvalidType, objectDecoder)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.parseFile">
            function <span class="apidocSignatureSpan">yamljs.</span>parseFile
            <span class="apidocSignatureSpan">(path, callback, exceptionOnInvalidType, objectDecoder)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.register">
            function <span class="apidocSignatureSpan">yamljs.</span>register
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.stringify">
            function <span class="apidocSignatureSpan">yamljs.</span>stringify
            <span class="apidocSignatureSpan">(input, inline, indent, exceptionOnInvalidType, objectEncoder)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.</span>Dumper.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.</span>Parser.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.</span>Pattern.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yamljs.Dumper">module yamljs.Dumper</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Dumper.Dumper">
            function <span class="apidocSignatureSpan">yamljs.</span>Dumper
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">yamljs.Dumper.</span>indentation</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yamljs.Dumper.prototype">module yamljs.Dumper.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Dumper.prototype.dump">
            function <span class="apidocSignatureSpan">yamljs.Dumper.prototype.</span>dump
            <span class="apidocSignatureSpan">(input, inline, indent, exceptionOnInvalidType, objectEncoder)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yamljs.Escaper">module yamljs.Escaper</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Escaper.Escaper">
            function <span class="apidocSignatureSpan">yamljs.</span>Escaper
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Escaper.escapeWithDoubleQuotes">
            function <span class="apidocSignatureSpan">yamljs.Escaper.</span>escapeWithDoubleQuotes
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Escaper.escapeWithSingleQuotes">
            function <span class="apidocSignatureSpan">yamljs.Escaper.</span>escapeWithSingleQuotes
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Escaper.requiresDoubleQuoting">
            function <span class="apidocSignatureSpan">yamljs.Escaper.</span>requiresDoubleQuoting
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Escaper.requiresSingleQuoting">
            function <span class="apidocSignatureSpan">yamljs.Escaper.</span>requiresSingleQuoting
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Escaper.</span>LIST_ESCAPED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Escaper.</span>LIST_ESCAPEES</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Escaper.</span>MAPPING_ESCAPEES_TO_ESCAPED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Escaper.</span>PATTERN_CHARACTERS_TO_ESCAPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Escaper.</span>PATTERN_MAPPING_ESCAPEES</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Escaper.</span>PATTERN_SINGLE_QUOTING</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yamljs.Inline">module yamljs.Inline</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Inline.Inline">
            function <span class="apidocSignatureSpan">yamljs.</span>Inline
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Inline.configure">
            function <span class="apidocSignatureSpan">yamljs.Inline.</span>configure
            <span class="apidocSignatureSpan">(exceptionOnInvalidType, objectDecoder)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Inline.dump">
            function <span class="apidocSignatureSpan">yamljs.Inline.</span>dump
            <span class="apidocSignatureSpan">(value, exceptionOnInvalidType, objectEncoder)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Inline.dumpObject">
            function <span class="apidocSignatureSpan">yamljs.Inline.</span>dumpObject
            <span class="apidocSignatureSpan">(value, exceptionOnInvalidType, objectSupport)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Inline.evaluateScalar">
            function <span class="apidocSignatureSpan">yamljs.Inline.</span>evaluateScalar
            <span class="apidocSignatureSpan">(scalar, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Inline.parse">
            function <span class="apidocSignatureSpan">yamljs.Inline.</span>parse
            <span class="apidocSignatureSpan">(value, exceptionOnInvalidType, objectDecoder)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Inline.parseMapping">
            function <span class="apidocSignatureSpan">yamljs.Inline.</span>parseMapping
            <span class="apidocSignatureSpan">(mapping, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Inline.parseQuotedScalar">
            function <span class="apidocSignatureSpan">yamljs.Inline.</span>parseQuotedScalar
            <span class="apidocSignatureSpan">(scalar, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Inline.parseScalar">
            function <span class="apidocSignatureSpan">yamljs.Inline.</span>parseScalar
            <span class="apidocSignatureSpan">(scalar, delimiters, stringDelimiters, context, evaluate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Inline.parseSequence">
            function <span class="apidocSignatureSpan">yamljs.Inline.</span>parseSequence
            <span class="apidocSignatureSpan">(sequence, context)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Inline.</span>PATTERN_QUOTED_SCALAR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Inline.</span>PATTERN_SCALAR_BY_DELIMITERS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Inline.</span>PATTERN_THOUSAND_NUMERIC_SCALAR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Inline.</span>PATTERN_TRAILING_COMMENTS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Inline.</span>settings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">yamljs.Inline.</span>REGEX_QUOTED_STRING</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yamljs.Parser">module yamljs.Parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Parser.Parser">
            function <span class="apidocSignatureSpan">yamljs.</span>Parser
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yamljs.Parser.prototype">module yamljs.Parser.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Parser.prototype.cleanup">
            function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>cleanup
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Parser.prototype.getCurrentLineIndentation">
            function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>getCurrentLineIndentation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Parser.prototype.getNextEmbedBlock">
            function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>getNextEmbedBlock
            <span class="apidocSignatureSpan">(indentation, includeUnindentedCollection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Parser.prototype.getRealCurrentLineNb">
            function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>getRealCurrentLineNb
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Parser.prototype.isCurrentLineBlank">
            function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>isCurrentLineBlank
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Parser.prototype.isCurrentLineComment">
            function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>isCurrentLineComment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Parser.prototype.isCurrentLineEmpty">
            function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>isCurrentLineEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Parser.prototype.isNextLineIndented">
            function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>isNextLineIndented
            <span class="apidocSignatureSpan">(ignoreComments)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Parser.prototype.isNextLineUnIndentedCollection">
            function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>isNextLineUnIndentedCollection
            <span class="apidocSignatureSpan">(currentIndentation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Parser.prototype.isStringUnIndentedCollectionItem">
            function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>isStringUnIndentedCollectionItem
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Parser.prototype.moveToNextLine">
            function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>moveToNextLine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Parser.prototype.moveToPreviousLine">
            function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>moveToPreviousLine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Parser.prototype.parse">
            function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>parse
            <span class="apidocSignatureSpan">(value, exceptionOnInvalidType, objectDecoder)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Parser.prototype.parseFoldedScalar">
            function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>parseFoldedScalar
            <span class="apidocSignatureSpan">(separator, indicator, indentation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Parser.prototype.parseValue">
            function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>parseValue
            <span class="apidocSignatureSpan">(value, exceptionOnInvalidType, objectDecoder)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>CONTEXT_MAPPING</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>CONTEXT_NONE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>CONTEXT_SEQUENCE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>PATTERN_ANCHOR_VALUE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>PATTERN_COMPACT_NOTATION</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>PATTERN_DECIMAL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>PATTERN_DOCUMENT_MARKER_END</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>PATTERN_DOCUMENT_MARKER_START</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>PATTERN_FOLDED_SCALAR_ALL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>PATTERN_FOLDED_SCALAR_BY_INDENTATION</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>PATTERN_FOLDED_SCALAR_END</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>PATTERN_INDENT_SPACES</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>PATTERN_LEADING_COMMENTS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>PATTERN_MAPPING_ITEM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>PATTERN_SEQUENCE_ITEM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>PATTERN_TRAILING_LINES</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>PATTERN_YAML_HEADER</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yamljs.Pattern">module yamljs.Pattern</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Pattern.Pattern">
            function <span class="apidocSignatureSpan">yamljs.</span>Pattern
            <span class="apidocSignatureSpan">(rawRegex, modifiers)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yamljs.Pattern.prototype">module yamljs.Pattern.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Pattern.prototype.exec">
            function <span class="apidocSignatureSpan">yamljs.Pattern.prototype.</span>exec
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Pattern.prototype.replace">
            function <span class="apidocSignatureSpan">yamljs.Pattern.prototype.</span>replace
            <span class="apidocSignatureSpan">(str, replacement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Pattern.prototype.replaceAll">
            function <span class="apidocSignatureSpan">yamljs.Pattern.prototype.</span>replaceAll
            <span class="apidocSignatureSpan">(str, replacement, limit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Pattern.prototype.test">
            function <span class="apidocSignatureSpan">yamljs.Pattern.prototype.</span>test
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Pattern.prototype.</span>cleanedRegex</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Pattern.prototype.</span>mapping</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Pattern.prototype.</span>rawRegex</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Pattern.prototype.</span>regex</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yamljs.Unescaper">module yamljs.Unescaper</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Unescaper.Unescaper">
            function <span class="apidocSignatureSpan">yamljs.</span>Unescaper
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Unescaper.unescapeCharacter">
            function <span class="apidocSignatureSpan">yamljs.Unescaper.</span>unescapeCharacter
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Unescaper.unescapeDoubleQuotedString">
            function <span class="apidocSignatureSpan">yamljs.Unescaper.</span>unescapeDoubleQuotedString
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Unescaper.unescapeSingleQuotedString">
            function <span class="apidocSignatureSpan">yamljs.Unescaper.</span>unescapeSingleQuotedString
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Unescaper.</span>PATTERN_ESCAPED_CHARACTER</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yamljs.Utils">module yamljs.Utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Utils.Utils">
            function <span class="apidocSignatureSpan">yamljs.</span>Utils
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Utils.getStringFromFile">
            function <span class="apidocSignatureSpan">yamljs.Utils.</span>getStringFromFile
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Utils.hexDec">
            function <span class="apidocSignatureSpan">yamljs.Utils.</span>hexDec
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Utils.isDigits">
            function <span class="apidocSignatureSpan">yamljs.Utils.</span>isDigits
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Utils.isEmpty">
            function <span class="apidocSignatureSpan">yamljs.Utils.</span>isEmpty
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Utils.isEmptyObject">
            function <span class="apidocSignatureSpan">yamljs.Utils.</span>isEmptyObject
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Utils.isNumeric">
            function <span class="apidocSignatureSpan">yamljs.Utils.</span>isNumeric
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Utils.ltrim">
            function <span class="apidocSignatureSpan">yamljs.Utils.</span>ltrim
            <span class="apidocSignatureSpan">(str, _char)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Utils.octDec">
            function <span class="apidocSignatureSpan">yamljs.Utils.</span>octDec
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Utils.parseBoolean">
            function <span class="apidocSignatureSpan">yamljs.Utils.</span>parseBoolean
            <span class="apidocSignatureSpan">(input, strict)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Utils.rtrim">
            function <span class="apidocSignatureSpan">yamljs.Utils.</span>rtrim
            <span class="apidocSignatureSpan">(str, _char)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Utils.strRepeat">
            function <span class="apidocSignatureSpan">yamljs.Utils.</span>strRepeat
            <span class="apidocSignatureSpan">(str, number)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Utils.stringToDate">
            function <span class="apidocSignatureSpan">yamljs.Utils.</span>stringToDate
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Utils.subStrCount">
            function <span class="apidocSignatureSpan">yamljs.Utils.</span>subStrCount
            <span class="apidocSignatureSpan">(string, subString, start, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Utils.trim">
            function <span class="apidocSignatureSpan">yamljs.Utils.</span>trim
            <span class="apidocSignatureSpan">(str, _char)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yamljs.Utils.utf8chr">
            function <span class="apidocSignatureSpan">yamljs.Utils.</span>utf8chr
            <span class="apidocSignatureSpan">(c)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">yamljs.Utils.</span>LOCAL_TIMEZONE_OFFSET</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Utils.</span>PATTERN_DATE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Utils.</span>REGEX_DIGITS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Utils.</span>REGEX_HEXADECIMAL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Utils.</span>REGEX_LEFT_TRIM_BY_CHAR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Utils.</span>REGEX_OCTAL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Utils.</span>REGEX_RIGHT_TRIM_BY_CHAR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yamljs.Utils.</span>REGEX_SPACES</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yamljs" id="apidoc.module.yamljs">module yamljs</a></h1>


    <h2>
        <a href="#apidoc.element.yamljs.Dumper" id="apidoc.element.yamljs.Dumper">
        function <span class="apidocSignatureSpan">yamljs.</span>Dumper
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Dumper() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Escaper" id="apidoc.element.yamljs.Escaper">
        function <span class="apidocSignatureSpan">yamljs.</span>Escaper
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Escaper() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Inline" id="apidoc.element.yamljs.Inline">
        function <span class="apidocSignatureSpan">yamljs.</span>Inline
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Inline() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Parser" id="apidoc.element.yamljs.Parser">
        function <span class="apidocSignatureSpan">yamljs.</span>Parser
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(offset) {
  this.offset = offset != null ? offset : 0;
  this.lines = [];
  this.currentLineNb = -1;
  this.currentLine = &#x27;&#x27;;
  this.refs = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Pattern" id="apidoc.element.yamljs.Pattern">
        function <span class="apidocSignatureSpan">yamljs.</span>Pattern
        <span class="apidocSignatureSpan">(rawRegex, modifiers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pattern(rawRegex, modifiers) {
  var _char, capturingBracketNumber, cleanedRegex, i, len, mapping, name, part, subChar;
  if (modifiers == null) {
    modifiers = &#x27;&#x27;;
  }
  cleanedRegex = &#x27;&#x27;;
  len = rawRegex.length;
  mapping = null;
  capturingBracketNumber = 0;
  i = 0;
  while (i &#x3c; len) {
    _char = rawRegex.charAt(i);
    if (_char === &#x27;\\&#x27;) {
      cleanedRegex += rawRegex.slice(i, +(i + 1) + 1 || 9e9);
      i++;
    } else if (_char === &#x27;(&#x27;) {
      if (i &#x3c; len - 2) {
        part = rawRegex.slice(i, +(i + 2) + 1 || 9e9);
        if (part === &#x27;(?:&#x27;) {
          i += 2;
          cleanedRegex += part;
        } else if (part === &#x27;(?&#x3c;&#x27;) {
          capturingBracketNumber++;
          i += 2;
          name = &#x27;&#x27;;
          while (i + 1 &#x3c; len) {
            subChar = rawRegex.charAt(i + 1);
            if (subChar === &#x27;&#x3e;&#x27;) {
              cleanedRegex += &#x27;(&#x27;;
              i++;
              if (name.length &#x3e; 0) {
                if (mapping == null) {
                  mapping = {};
                }
                mapping[name] = capturingBracketNumber;
              }
              break;
            } else {
              name += subChar;
            }
            i++;
          }
        } else {
          cleanedRegex += _char;
          capturingBracketNumber++;
        }
      } else {
        cleanedRegex += _char;
      }
    } else {
      cleanedRegex += _char;
    }
    i++;
  }
  this.rawRegex = rawRegex;
  this.cleanedRegex = cleanedRegex;
  this.regex = new RegExp(this.cleanedRegex, &#x27;g&#x27; + modifiers.replace(&#x27;g&#x27;, &#x27;&#x27;));
  this.mapping = mapping;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Unescaper" id="apidoc.element.yamljs.Unescaper">
        function <span class="apidocSignatureSpan">yamljs.</span>Unescaper
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Unescaper() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Utils" id="apidoc.element.yamljs.Utils">
        function <span class="apidocSignatureSpan">yamljs.</span>Utils
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Utils() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.dump" id="apidoc.element.yamljs.dump">
        function <span class="apidocSignatureSpan">yamljs.</span>dump
        <span class="apidocSignatureSpan">(input, inline, indent, exceptionOnInvalidType, objectEncoder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dump = function (input, inline, indent, exceptionOnInvalidType, objectEncoder) {
  var yaml;
  if (inline == null) {
    inline = 2;
  }
  if (indent == null) {
    indent = 4;
  }
  if (exceptionOnInvalidType == null) {
    exceptionOnInvalidType = false;
  }
  if (objectEncoder == null) {
    objectEncoder = null;
  }
  yaml = new Dumper();
  yaml.indentation = indent;
  return yaml.dump(input, inline, 0, exceptionOnInvalidType, objectEncoder);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (objectEncoder == null) {
  objectEncoder = null;
}
output = &#x27;&#x27;;
prefix = (indent ? Utils.strRepeat(&#x27; &#x27;, indent) : &#x27;&#x27;);
if (inline &#x3c;= 0 || typeof input !== &#x27;object&#x27; || input instanceof Date || Utils.isEmpty(input)) {
  output += prefix + Inline.<span class="apidocCodeKeywordSpan">dump</span>(input, exceptionOnInvalidType, objectEncoder);
} else {
  if (input instanceof Array) {
    for (i = 0, len = input.length; i &#x3c; len; i++) {
      value = input[i];
      willBeInlined = inline - 1 &#x3c;= 0 || typeof value !== &#x27;object&#x27; || Utils.isEmpty(value);
      output += prefix + &#x27;-&#x27; + (willBeInlined ? &#x27; &#x27; : &#x22;\n&#x22;) + this.dump(value, inline - 1, (willBeInlined
 ? 0 : indent + this.indentation), exceptionOnInvalidType, objectEncoder) + (willBeInlined ? &#x22;\n&#x22; : &#x27;&#x27;);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.load" id="apidoc.element.yamljs.load">
        function <span class="apidocSignatureSpan">yamljs.</span>load
        <span class="apidocSignatureSpan">(path, callback, exceptionOnInvalidType, objectDecoder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (path, callback, exceptionOnInvalidType, objectDecoder) {
  return this.parseFile(path, callback, exceptionOnInvalidType, objectDecoder);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
``` js
yamlString = YAML.stringify(nativeObject[, inline /* @integer depth to start using inline notation at */[, spaces /* @integer number
 of spaces to use for indentation */] ]);
```

Load yaml file:

``` js
nativeObject = YAML.<span class="apidocCodeKeywordSpan">load</span>(&#x27;file.yml&#x27;);
```

Load yaml file:

``` js
YAML.load(&#x27;file.yml&#x27;, function(result)
{
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.parse" id="apidoc.element.yamljs.parse">
        function <span class="apidocSignatureSpan">yamljs.</span>parse
        <span class="apidocSignatureSpan">(input, exceptionOnInvalidType, objectDecoder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (input, exceptionOnInvalidType, objectDecoder) {
  if (exceptionOnInvalidType == null) {
    exceptionOnInvalidType = false;
  }
  if (objectDecoder == null) {
    objectDecoder = null;
  }
  return new Parser().parse(input, exceptionOnInvalidType, objectDecoder);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
``` html
&#x3c;script type=&#x22;text/javascript&#x22; src=&#x22;yaml.js&#x22;&#x3e;&#x3c;/script&#x3e;
```

Parse yaml string:

``` js
nativeObject = YAML.<span class="apidocCodeKeywordSpan">parse</span>(yamlString);
```

Dump native object into yaml string:

``` js
yamlString = YAML.stringify(nativeObject[, inline /* @integer depth to start using inline notation at */[, spaces /* @integer number
 of spaces to use for indentation */] ]);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.parseFile" id="apidoc.element.yamljs.parseFile">
        function <span class="apidocSignatureSpan">yamljs.</span>parseFile
        <span class="apidocSignatureSpan">(path, callback, exceptionOnInvalidType, objectDecoder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseFile = function (path, callback, exceptionOnInvalidType, objectDecoder) {
  var input;
  if (callback == null) {
    callback = null;
  }
  if (exceptionOnInvalidType == null) {
    exceptionOnInvalidType = false;
  }
  if (objectDecoder == null) {
    objectDecoder = null;
  }
  if (callback != null) {
    return Utils.getStringFromFile(path, (function(_this) {
      return function(input) {
        var result;
        result = null;
        if (input != null) {
          result = _this.parse(input, exceptionOnInvalidType, objectDecoder);
        }
        callback(result);
      };
    })(this));
  } else {
    input = Utils.getStringFromFile(path);
    if (input != null) {
      return this.parse(input, exceptionOnInvalidType, objectDecoder);
    }
    return null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.register" id="apidoc.element.yamljs.register">
        function <span class="apidocSignatureSpan">yamljs.</span>register
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">register = function () {
  var require_handler;
  require_handler = function(module, filename) {
    return module.exports = YAML.parseFile(filename);
  };
  if ((typeof require !== &#x22;undefined&#x22; &#x26;&#x26; require !== null ? require.extensions : void 0) != null) {
    require.extensions[&#x27;.yml&#x27;] = require_handler;
    return require.extensions[&#x27;.yaml&#x27;] = require_handler;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.stringify" id="apidoc.element.yamljs.stringify">
        function <span class="apidocSignatureSpan">yamljs.</span>stringify
        <span class="apidocSignatureSpan">(input, inline, indent, exceptionOnInvalidType, objectEncoder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringify = function (input, inline, indent, exceptionOnInvalidType, objectEncoder) {
  return this.dump(input, inline, indent, exceptionOnInvalidType, objectEncoder);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
``` js
nativeObject = YAML.parse(yamlString);
```

Dump native object into yaml string:

``` js
yamlString = YAML.<span class="apidocCodeKeywordSpan">stringify</span>(nativeObject[, inline /* @integer depth to start using inline
 notation at */[, spaces /* @integer number of spaces to use for indentation */] ]);
```

Load yaml file:

``` js
nativeObject = YAML.load(&#x27;file.yml&#x27;);
```
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yamljs.Dumper" id="apidoc.module.yamljs.Dumper">module yamljs.Dumper</a></h1>


    <h2>
        <a href="#apidoc.element.yamljs.Dumper.Dumper" id="apidoc.element.yamljs.Dumper.Dumper">
        function <span class="apidocSignatureSpan">yamljs.</span>Dumper
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Dumper() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yamljs.Dumper.prototype" id="apidoc.module.yamljs.Dumper.prototype">module yamljs.Dumper.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.yamljs.Dumper.prototype.dump" id="apidoc.element.yamljs.Dumper.prototype.dump">
        function <span class="apidocSignatureSpan">yamljs.Dumper.prototype.</span>dump
        <span class="apidocSignatureSpan">(input, inline, indent, exceptionOnInvalidType, objectEncoder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dump = function (input, inline, indent, exceptionOnInvalidType, objectEncoder) {
  var i, key, len, output, prefix, value, willBeInlined;
  if (inline == null) {
    inline = 0;
  }
  if (indent == null) {
    indent = 0;
  }
  if (exceptionOnInvalidType == null) {
    exceptionOnInvalidType = false;
  }
  if (objectEncoder == null) {
    objectEncoder = null;
  }
  output = &#x27;&#x27;;
  prefix = (indent ? Utils.strRepeat(&#x27; &#x27;, indent) : &#x27;&#x27;);
  if (inline &#x3c;= 0 || typeof input !== &#x27;object&#x27; || input instanceof Date || Utils.isEmpty(input)) {
    output += prefix + Inline.dump(input, exceptionOnInvalidType, objectEncoder);
  } else {
    if (input instanceof Array) {
      for (i = 0, len = input.length; i &#x3c; len; i++) {
        value = input[i];
        willBeInlined = inline - 1 &#x3c;= 0 || typeof value !== &#x27;object&#x27; || Utils.isEmpty(value);
        output += prefix + &#x27;-&#x27; + (willBeInlined ? &#x27; &#x27; : &#x22;\n&#x22;) + this.dump(value, inline - 1, (willBeInlined ? 0 : indent + this.
indentation), exceptionOnInvalidType, objectEncoder) + (willBeInlined ? &#x22;\n&#x22; : &#x27;&#x27;);
      }
    } else {
      for (key in input) {
        value = input[key];
        willBeInlined = inline - 1 &#x3c;= 0 || typeof value !== &#x27;object&#x27; || Utils.isEmpty(value);
        output += prefix + Inline.dump(key, exceptionOnInvalidType, objectEncoder) + &#x27;:&#x27; + (willBeInlined ? &#x27; &#x27; : &#x22;\n&#x22;) + this.dump
(value, inline - 1, (willBeInlined ? 0 : indent + this.indentation), exceptionOnInvalidType, objectEncoder) + (willBeInlined ? &#x22;\n&#x22; : &#x27;&#x27;);
      }
    }
  }
  return output;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (objectEncoder == null) {
  objectEncoder = null;
}
output = &#x27;&#x27;;
prefix = (indent ? Utils.strRepeat(&#x27; &#x27;, indent) : &#x27;&#x27;);
if (inline &#x3c;= 0 || typeof input !== &#x27;object&#x27; || input instanceof Date || Utils.isEmpty(input)) {
  output += prefix + Inline.<span class="apidocCodeKeywordSpan">dump</span>(input, exceptionOnInvalidType, objectEncoder);
} else {
  if (input instanceof Array) {
    for (i = 0, len = input.length; i &#x3c; len; i++) {
      value = input[i];
      willBeInlined = inline - 1 &#x3c;= 0 || typeof value !== &#x27;object&#x27; || Utils.isEmpty(value);
      output += prefix + &#x27;-&#x27; + (willBeInlined ? &#x27; &#x27; : &#x22;\n&#x22;) + this.dump(value, inline - 1, (willBeInlined
 ? 0 : indent + this.indentation), exceptionOnInvalidType, objectEncoder) + (willBeInlined ? &#x22;\n&#x22; : &#x27;&#x27;);
    }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yamljs.Escaper" id="apidoc.module.yamljs.Escaper">module yamljs.Escaper</a></h1>


    <h2>
        <a href="#apidoc.element.yamljs.Escaper.Escaper" id="apidoc.element.yamljs.Escaper.Escaper">
        function <span class="apidocSignatureSpan">yamljs.</span>Escaper
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Escaper() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Escaper.escapeWithDoubleQuotes" id="apidoc.element.yamljs.Escaper.escapeWithDoubleQuotes">
        function <span class="apidocSignatureSpan">yamljs.Escaper.</span>escapeWithDoubleQuotes
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">escapeWithDoubleQuotes = function (value) {
  var result;
  result = this.PATTERN_MAPPING_ESCAPEES.replace(value, (function(_this) {
    return function(str) {
      return _this.MAPPING_ESCAPEES_TO_ESCAPED[str];
    };
  })(this));
  return &#x27;&#x22;&#x27; + result + &#x27;&#x22;&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (Utils.isNumeric(value)) {
  return (type === &#x27;string&#x27; ? &#x22;&#x27;&#x22; + value + &#x22;&#x27;&#x22; : String(parseFloat(value)));
}
if (type === &#x27;number&#x27;) {
  return (value === 2e308 ? &#x27;.Inf&#x27; : (value === -2e308 ? &#x27;-.Inf&#x27; : (isNaN(value) ? &#x27;.NaN&#x27; : value)));
}
if (Escaper.requiresDoubleQuoting(value)) {
  return Escaper.<span class="apidocCodeKeywordSpan">escapeWithDoubleQuotes</span>(value);
}
if (Escaper.requiresSingleQuoting(value)) {
  return Escaper.escapeWithSingleQuotes(value);
}
if (&#x27;&#x27; === value) {
  return &#x27;&#x22;&#x22;&#x27;;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Escaper.escapeWithSingleQuotes" id="apidoc.element.yamljs.Escaper.escapeWithSingleQuotes">
        function <span class="apidocSignatureSpan">yamljs.Escaper.</span>escapeWithSingleQuotes
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">escapeWithSingleQuotes = function (value) {
  return &#x22;&#x27;&#x22; + value.replace(/&#x27;/g, &#x22;&#x27;&#x27;&#x22;) + &#x22;&#x27;&#x22;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (type === &#x27;number&#x27;) {
  return (value === 2e308 ? &#x27;.Inf&#x27; : (value === -2e308 ? &#x27;-.Inf&#x27; : (isNaN(value) ? &#x27;.NaN&#x27; : value)));
}
if (Escaper.requiresDoubleQuoting(value)) {
  return Escaper.escapeWithDoubleQuotes(value);
}
if (Escaper.requiresSingleQuoting(value)) {
  return Escaper.<span class="apidocCodeKeywordSpan">escapeWithSingleQuotes</span>(value);
}
if (&#x27;&#x27; === value) {
  return &#x27;&#x22;&#x22;&#x27;;
}
if (Utils.PATTERN_DATE.test(value)) {
  return &#x22;&#x27;&#x22; + value + &#x22;&#x27;&#x22;;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Escaper.requiresDoubleQuoting" id="apidoc.element.yamljs.Escaper.requiresDoubleQuoting">
        function <span class="apidocSignatureSpan">yamljs.Escaper.</span>requiresDoubleQuoting
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">requiresDoubleQuoting = function (value) {
  return this.PATTERN_CHARACTERS_TO_ESCAPE.test(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (Utils.isNumeric(value)) {
  return (type === &#x27;string&#x27; ? &#x22;&#x27;&#x22; + value + &#x22;&#x27;&#x22; : String(parseFloat(value)));
}
if (type === &#x27;number&#x27;) {
  return (value === 2e308 ? &#x27;.Inf&#x27; : (value === -2e308 ? &#x27;-.Inf&#x27; : (isNaN(value) ? &#x27;.NaN&#x27; : value)));
}
if (Escaper.<span class="apidocCodeKeywordSpan">requiresDoubleQuoting</span>(value)) {
  return Escaper.escapeWithDoubleQuotes(value);
}
if (Escaper.requiresSingleQuoting(value)) {
  return Escaper.escapeWithSingleQuotes(value);
}
if (&#x27;&#x27; === value) {
  return &#x27;&#x22;&#x22;&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Escaper.requiresSingleQuoting" id="apidoc.element.yamljs.Escaper.requiresSingleQuoting">
        function <span class="apidocSignatureSpan">yamljs.Escaper.</span>requiresSingleQuoting
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">requiresSingleQuoting = function (value) {
  return this.PATTERN_SINGLE_QUOTING.test(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (type === &#x27;number&#x27;) {
  return (value === 2e308 ? &#x27;.Inf&#x27; : (value === -2e308 ? &#x27;-.Inf&#x27; : (isNaN(value) ? &#x27;.NaN&#x27; : value)));
}
if (Escaper.requiresDoubleQuoting(value)) {
  return Escaper.escapeWithDoubleQuotes(value);
}
if (Escaper.<span class="apidocCodeKeywordSpan">requiresSingleQuoting</span>(value)) {
  return Escaper.escapeWithSingleQuotes(value);
}
if (&#x27;&#x27; === value) {
  return &#x27;&#x22;&#x22;&#x27;;
}
if (Utils.PATTERN_DATE.test(value)) {
  return &#x22;&#x27;&#x22; + value + &#x22;&#x27;&#x22;;
...</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yamljs.Inline" id="apidoc.module.yamljs.Inline">module yamljs.Inline</a></h1>


    <h2>
        <a href="#apidoc.element.yamljs.Inline.Inline" id="apidoc.element.yamljs.Inline.Inline">
        function <span class="apidocSignatureSpan">yamljs.</span>Inline
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Inline() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Inline.configure" id="apidoc.element.yamljs.Inline.configure">
        function <span class="apidocSignatureSpan">yamljs.Inline.</span>configure
        <span class="apidocSignatureSpan">(exceptionOnInvalidType, objectDecoder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (exceptionOnInvalidType, objectDecoder) {
  if (exceptionOnInvalidType == null) {
    exceptionOnInvalidType = null;
  }
  if (objectDecoder == null) {
    objectDecoder = null;
  }
  this.settings.exceptionOnInvalidType = exceptionOnInvalidType;
  this.settings.objectDecoder = objectDecoder;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.CONTEXT_SEQUENCE === context) {
  throw new ParseException(&#x27;You cannot define a mapping item when in a sequence&#x27;);
}
context = this.CONTEXT_MAPPING;
if (data == null) {
  data = {};
}
Inline.<span class="apidocCodeKeywordSpan">configure</span>(exceptionOnInvalidType, objectDecoder);
try {
  key = Inline.parseScalar(values.key);
} catch (error) {
  e = error;
  e.parsedLine = this.getRealCurrentLineNb() + 1;
  e.snippet = this.currentLine;
  throw e;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Inline.dump" id="apidoc.element.yamljs.Inline.dump">
        function <span class="apidocSignatureSpan">yamljs.Inline.</span>dump
        <span class="apidocSignatureSpan">(value, exceptionOnInvalidType, objectEncoder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dump = function (value, exceptionOnInvalidType, objectEncoder) {
  var ref, result, type;
  if (exceptionOnInvalidType == null) {
    exceptionOnInvalidType = false;
  }
  if (objectEncoder == null) {
    objectEncoder = null;
  }
  if (value == null) {
    return &#x27;null&#x27;;
  }
  type = typeof value;
  if (type === &#x27;object&#x27;) {
    if (value instanceof Date) {
      return value.toISOString();
    } else if (objectEncoder != null) {
      result = objectEncoder(value);
      if (typeof result === &#x27;string&#x27; || (result != null)) {
        return result;
      }
    }
    return this.dumpObject(value);
  }
  if (type === &#x27;boolean&#x27;) {
    return (value ? &#x27;true&#x27; : &#x27;false&#x27;);
  }
  if (Utils.isDigits(value)) {
    return (type === &#x27;string&#x27; ? &#x22;&#x27;&#x22; + value + &#x22;&#x27;&#x22; : String(parseInt(value)));
  }
  if (Utils.isNumeric(value)) {
    return (type === &#x27;string&#x27; ? &#x22;&#x27;&#x22; + value + &#x22;&#x27;&#x22; : String(parseFloat(value)));
  }
  if (type === &#x27;number&#x27;) {
    return (value === 2e308 ? &#x27;.Inf&#x27; : (value === -2e308 ? &#x27;-.Inf&#x27; : (isNaN(value) ? &#x27;.NaN&#x27; : value)));
  }
  if (Escaper.requiresDoubleQuoting(value)) {
    return Escaper.escapeWithDoubleQuotes(value);
  }
  if (Escaper.requiresSingleQuoting(value)) {
    return Escaper.escapeWithSingleQuotes(value);
  }
  if (&#x27;&#x27; === value) {
    return &#x27;&#x22;&#x22;&#x27;;
  }
  if (Utils.PATTERN_DATE.test(value)) {
    return &#x22;&#x27;&#x22; + value + &#x22;&#x27;&#x22;;
  }
  if ((ref = value.toLowerCase()) === &#x27;null&#x27; || ref === &#x27;~&#x27; || ref === &#x27;true&#x27; || ref === &#x27;false&#x27;) {
    return &#x22;&#x27;&#x22; + value + &#x22;&#x27;&#x22;;
  }
  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (objectEncoder == null) {
  objectEncoder = null;
}
output = &#x27;&#x27;;
prefix = (indent ? Utils.strRepeat(&#x27; &#x27;, indent) : &#x27;&#x27;);
if (inline &#x3c;= 0 || typeof input !== &#x27;object&#x27; || input instanceof Date || Utils.isEmpty(input)) {
  output += prefix + Inline.<span class="apidocCodeKeywordSpan">dump</span>(input, exceptionOnInvalidType, objectEncoder);
} else {
  if (input instanceof Array) {
    for (i = 0, len = input.length; i &#x3c; len; i++) {
      value = input[i];
      willBeInlined = inline - 1 &#x3c;= 0 || typeof value !== &#x27;object&#x27; || Utils.isEmpty(value);
      output += prefix + &#x27;-&#x27; + (willBeInlined ? &#x27; &#x27; : &#x22;\n&#x22;) + this.dump(value, inline - 1, (willBeInlined
 ? 0 : indent + this.indentation), exceptionOnInvalidType, objectEncoder) + (willBeInlined ? &#x22;\n&#x22; : &#x27;&#x27;);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Inline.dumpObject" id="apidoc.element.yamljs.Inline.dumpObject">
        function <span class="apidocSignatureSpan">yamljs.Inline.</span>dumpObject
        <span class="apidocSignatureSpan">(value, exceptionOnInvalidType, objectSupport)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dumpObject = function (value, exceptionOnInvalidType, objectSupport) {
  var j, key, len1, output, val;
  if (objectSupport == null) {
    objectSupport = null;
  }
  if (value instanceof Array) {
    output = [];
    for (j = 0, len1 = value.length; j &#x3c; len1; j++) {
      val = value[j];
      output.push(this.dump(val));
    }
    return &#x27;[&#x27; + output.join(&#x27;, &#x27;) + &#x27;]&#x27;;
  } else {
    output = [];
    for (key in value) {
      val = value[key];
      output.push(this.dump(key) + &#x27;: &#x27; + this.dump(val));
    }
    return &#x27;{&#x27; + output.join(&#x27;, &#x27;) + &#x27;}&#x27;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return value.toISOString();
  } else if (objectEncoder != null) {
    result = objectEncoder(value);
    if (typeof result === &#x27;string&#x27; || (result != null)) {
      return result;
    }
  }
  return this.<span class="apidocCodeKeywordSpan">dumpObject</span>(value);
}
if (type === &#x27;boolean&#x27;) {
  return (value ? &#x27;true&#x27; : &#x27;false&#x27;);
}
if (Utils.isDigits(value)) {
  return (type === &#x27;string&#x27; ? &#x22;&#x27;&#x22; + value + &#x22;&#x27;&#x22; : String(parseInt(value)));
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Inline.evaluateScalar" id="apidoc.element.yamljs.Inline.evaluateScalar">
        function <span class="apidocSignatureSpan">yamljs.Inline.</span>evaluateScalar
        <span class="apidocSignatureSpan">(scalar, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">evaluateScalar = function (scalar, context) {
  var cast, date, exceptionOnInvalidType, firstChar, firstSpace, firstWord, objectDecoder, raw, scalarLower, subValue, trimmedScalar
;
  scalar = Utils.trim(scalar);
  scalarLower = scalar.toLowerCase();
  switch (scalarLower) {
    case &#x27;null&#x27;:
    case &#x27;&#x27;:
    case &#x27;~&#x27;:
      return null;
    case &#x27;true&#x27;:
      return true;
    case &#x27;false&#x27;:
      return false;
    case &#x27;.inf&#x27;:
      return 2e308;
    case &#x27;.nan&#x27;:
      return 0/0;
    case &#x27;-.inf&#x27;:
      return 2e308;
    default:
      firstChar = scalarLower.charAt(0);
      switch (firstChar) {
        case &#x27;!&#x27;:
          firstSpace = scalar.indexOf(&#x27; &#x27;);
          if (firstSpace === -1) {
            firstWord = scalarLower;
          } else {
            firstWord = scalarLower.slice(0, firstSpace);
          }
          switch (firstWord) {
            case &#x27;!&#x27;:
              if (firstSpace !== -1) {
                return parseInt(this.parseScalar(scalar.slice(2)));
              }
              return null;
            case &#x27;!str&#x27;:
              return Utils.ltrim(scalar.slice(4));
            case &#x27;!!str&#x27;:
              return Utils.ltrim(scalar.slice(5));
            case &#x27;!!int&#x27;:
              return parseInt(this.parseScalar(scalar.slice(5)));
            case &#x27;!!bool&#x27;:
              return Utils.parseBoolean(this.parseScalar(scalar.slice(6)), false);
            case &#x27;!!float&#x27;:
              return parseFloat(this.parseScalar(scalar.slice(7)));
            case &#x27;!!timestamp&#x27;:
              return Utils.stringToDate(Utils.ltrim(scalar.slice(11)));
            default:
              if (context == null) {
                context = {
                  exceptionOnInvalidType: this.settings.exceptionOnInvalidType,
                  objectDecoder: this.settings.objectDecoder,
                  i: 0
                };
              }
              objectDecoder = context.objectDecoder, exceptionOnInvalidType = context.exceptionOnInvalidType;
              if (objectDecoder) {
                trimmedScalar = Utils.rtrim(scalar);
                firstSpace = trimmedScalar.indexOf(&#x27; &#x27;);
                if (firstSpace === -1) {
                  return objectDecoder(trimmedScalar, null);
                } else {
                  subValue = Utils.ltrim(trimmedScalar.slice(firstSpace + 1));
                  if (!(subValue.length &#x3e; 0)) {
                    subValue = null;
                  }
                  return objectDecoder(trimmedScalar.slice(0, firstSpace), subValue);
                }
              }
              if (exceptionOnInvalidType) {
                throw new ParseException(&#x27;Custom object support when parsing a YAML file has been disabled.&#x27;);
              }
              return null;
          }
          break;
        case &#x27;0&#x27;:
          if (&#x27;0x&#x27; === scalar.slice(0, 2)) {
            return Utils.hexDec(scalar);
          } else if (Utils.isDigits(scalar)) {
            return Utils.octDec(scalar);
          } else if (Utils.isNumeric(scalar)) {
            return parseFloat(scalar);
          } else {
            return scalar;
          }
          break;
        case &#x27;+&#x27;:
          if (Utils.isDigits(scalar)) {
            raw = scalar;
            cast = parseInt(raw);
            if (raw === String(cast)) {
              return cast;
            } else {
              return raw;
            }
          } else if (Utils.isNumeric(scalar)) {
            return parseFloat(scalar);
          } else if (this.PATTERN_THOUSAND_NUMERIC_SCALAR.test(scalar)) {
            return parseFloat(scalar.replace(&#x27;,&#x27;, &#x27;&#x27;));
          }
          return scalar;
        case &#x27;-&#x27;:
          if (Utils.isDigits(scalar.slice(1))) {
            if (&#x27;0&#x27; === scalar.charAt(1)) {
              return -Utils.octDec(scalar.slice(1));
            } else {
              raw = scalar.slice(1);
              cast = parseInt(raw);
              if (raw === String(cast)) {
                return -cast;
              } else {
                return -raw;
              }
            }
          } else if (Utils.isNumeric(scalar)) {
            retu ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        output = match[1];
        i += output.length;
      } else {
        throw new ParseException(&#x27;Malformed inline YAML string (&#x27; + scalar + &#x27;).&#x27;);
      }
    }
    if (evaluate) {
      output = this.<span class="apidocCodeKeywordSpan">evaluateScalar</span>(output, context);
    }
  }
  context.i = i;
  return output;
};

Inline.parseQuotedScalar = function(scalar, context) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Inline.parse" id="apidoc.element.yamljs.Inline.parse">
        function <span class="apidocSignatureSpan">yamljs.Inline.</span>parse
        <span class="apidocSignatureSpan">(value, exceptionOnInvalidType, objectDecoder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (value, exceptionOnInvalidType, objectDecoder) {
  var context, result;
  if (exceptionOnInvalidType == null) {
    exceptionOnInvalidType = false;
  }
  if (objectDecoder == null) {
    objectDecoder = null;
  }
  this.settings.exceptionOnInvalidType = exceptionOnInvalidType;
  this.settings.objectDecoder = objectDecoder;
  if (value == null) {
    return &#x27;&#x27;;
  }
  value = Utils.trim(value);
  if (0 === value.length) {
    return &#x27;&#x27;;
  }
  context = {
    exceptionOnInvalidType: exceptionOnInvalidType,
    objectDecoder: objectDecoder,
    i: 0
  };
  switch (value.charAt(0)) {
    case &#x27;[&#x27;:
      result = this.parseSequence(value, context);
      ++context.i;
      break;
    case &#x27;{&#x27;:
      result = this.parseMapping(value, context);
      ++context.i;
      break;
    default:
      result = this.parseScalar(value, null, [&#x27;&#x22;&#x27;, &#x22;&#x27;&#x22;], context);
  }
  if (this.PATTERN_TRAILING_COMMENTS.replace(value.slice(context.i), &#x27;&#x27;) !== &#x27;&#x27;) {
    throw new ParseException(&#x27;Unexpected characters near &#x22;&#x27; + value.slice(context.i) + &#x27;&#x22;.&#x27;);
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
``` html
&#x3c;script type=&#x22;text/javascript&#x22; src=&#x22;yaml.js&#x22;&#x3e;&#x3c;/script&#x3e;
```

Parse yaml string:

``` js
nativeObject = YAML.<span class="apidocCodeKeywordSpan">parse</span>(yamlString);
```

Dump native object into yaml string:

``` js
yamlString = YAML.stringify(nativeObject[, inline /* @integer depth to start using inline notation at */[, spaces /* @integer number
 of spaces to use for indentation */] ]);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Inline.parseMapping" id="apidoc.element.yamljs.Inline.parseMapping">
        function <span class="apidocSignatureSpan">yamljs.Inline.</span>parseMapping
        <span class="apidocSignatureSpan">(mapping, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseMapping = function (mapping, context) {
  var done, i, key, len, output, shouldContinueWhileLoop, value;
  output = {};
  len = mapping.length;
  i = context.i;
  i += 1;
  shouldContinueWhileLoop = false;
  while (i &#x3c; len) {
    context.i = i;
    switch (mapping.charAt(i)) {
      case &#x27; &#x27;:
      case &#x27;,&#x27;:
      case &#x22;\n&#x22;:
        ++i;
        context.i = i;
        shouldContinueWhileLoop = true;
        break;
      case &#x27;}&#x27;:
        return output;
    }
    if (shouldContinueWhileLoop) {
      shouldContinueWhileLoop = false;
      continue;
    }
    key = this.parseScalar(mapping, [&#x27;:&#x27;, &#x27; &#x27;, &#x22;\n&#x22;], [&#x27;&#x22;&#x27;, &#x22;&#x27;&#x22;], context, false);
    i = context.i;
    done = false;
    while (i &#x3c; len) {
      context.i = i;
      switch (mapping.charAt(i)) {
        case &#x27;[&#x27;:
          value = this.parseSequence(mapping, context);
          i = context.i;
          if (output[key] === void 0) {
            output[key] = value;
          }
          done = true;
          break;
        case &#x27;{&#x27;:
          value = this.parseMapping(mapping, context);
          i = context.i;
          if (output[key] === void 0) {
            output[key] = value;
          }
          done = true;
          break;
        case &#x27;:&#x27;:
        case &#x27; &#x27;:
        case &#x22;\n&#x22;:
          break;
        default:
          value = this.parseScalar(mapping, [&#x27;,&#x27;, &#x27;}&#x27;], [&#x27;&#x22;&#x27;, &#x22;&#x27;&#x22;], context);
          i = context.i;
          if (output[key] === void 0) {
            output[key] = value;
          }
          done = true;
          --i;
      }
      ++i;
      if (done) {
        break;
      }
    }
  }
  throw new ParseMore(&#x27;Malformed inline YAML string &#x27; + mapping);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
switch (value.charAt(0)) {
  case &#x27;[&#x27;:
    result = this.parseSequence(value, context);
    ++context.i;
    break;
  case &#x27;{&#x27;:
    result = this.<span class="apidocCodeKeywordSpan">parseMapping</span>(value, context);
    ++context.i;
    break;
  default:
    result = this.parseScalar(value, null, [&#x27;&#x22;&#x27;, &#x22;&#x27;&#x22;], context);
}
if (this.PATTERN_TRAILING_COMMENTS.replace(value.slice(context.i), &#x27;&#x27;) !== &#x27;&#x27;) {
  throw new ParseException(&#x27;Unexpected characters near &#x22;&#x27; + value.slice(context.i) + &#x27;&#x22;.&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Inline.parseQuotedScalar" id="apidoc.element.yamljs.Inline.parseQuotedScalar">
        function <span class="apidocSignatureSpan">yamljs.Inline.</span>parseQuotedScalar
        <span class="apidocSignatureSpan">(scalar, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseQuotedScalar = function (scalar, context) {
  var i, match, output;
  i = context.i;
  if (!(match = this.PATTERN_QUOTED_SCALAR.exec(scalar.slice(i)))) {
    throw new ParseMore(&#x27;Malformed inline YAML string (&#x27; + scalar.slice(i) + &#x27;).&#x27;);
  }
  output = match[0].substr(1, match[0].length - 2);
  if (&#x27;&#x22;&#x27; === scalar.charAt(i)) {
    output = Unescaper.unescapeDoubleQuotedString(output);
  } else {
    output = Unescaper.unescapeSingleQuotedString(output);
  }
  i += match[0].length;
  context.i = i;
  return output;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    exceptionOnInvalidType: this.settings.exceptionOnInvalidType,
    objectDecoder: this.settings.objectDecoder,
    i: 0
  };
}
i = context.i;
if (ref = scalar.charAt(i), indexOf.call(stringDelimiters, ref) &#x3e;= 0) {
  output = this.<span class="apidocCodeKeywordSpan">parseQuotedScalar</span>(scalar, context);
  i = context.i;
  if (delimiters != null) {
    tmp = Utils.ltrim(scalar.slice(i), &#x27; &#x27;);
    if (!(ref1 = tmp.charAt(0), indexOf.call(delimiters, ref1) &#x3e;= 0)) {
      throw new ParseException(&#x27;Unexpected characters (&#x27; + scalar.slice(i) + &#x27;).&#x27;);
    }
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Inline.parseScalar" id="apidoc.element.yamljs.Inline.parseScalar">
        function <span class="apidocSignatureSpan">yamljs.Inline.</span>parseScalar
        <span class="apidocSignatureSpan">(scalar, delimiters, stringDelimiters, context, evaluate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseScalar = function (scalar, delimiters, stringDelimiters, context, evaluate) {
  var i, joinedDelimiters, match, output, pattern, ref, ref1, strpos, tmp;
  if (delimiters == null) {
    delimiters = null;
  }
  if (stringDelimiters == null) {
    stringDelimiters = [&#x27;&#x22;&#x27;, &#x22;&#x27;&#x22;];
  }
  if (context == null) {
    context = null;
  }
  if (evaluate == null) {
    evaluate = true;
  }
  if (context == null) {
    context = {
      exceptionOnInvalidType: this.settings.exceptionOnInvalidType,
      objectDecoder: this.settings.objectDecoder,
      i: 0
    };
  }
  i = context.i;
  if (ref = scalar.charAt(i), indexOf.call(stringDelimiters, ref) &#x3e;= 0) {
    output = this.parseQuotedScalar(scalar, context);
    i = context.i;
    if (delimiters != null) {
      tmp = Utils.ltrim(scalar.slice(i), &#x27; &#x27;);
      if (!(ref1 = tmp.charAt(0), indexOf.call(delimiters, ref1) &#x3e;= 0)) {
        throw new ParseException(&#x27;Unexpected characters (&#x27; + scalar.slice(i) + &#x27;).&#x27;);
      }
    }
  } else {
    if (!delimiters) {
      output = scalar.slice(i);
      i += output.length;
      strpos = output.indexOf(&#x27; #&#x27;);
      if (strpos !== -1) {
        output = Utils.rtrim(output.slice(0, strpos));
      }
    } else {
      joinedDelimiters = delimiters.join(&#x27;|&#x27;);
      pattern = this.PATTERN_SCALAR_BY_DELIMITERS[joinedDelimiters];
      if (pattern == null) {
        pattern = new Pattern(&#x27;^(.+?)(&#x27; + joinedDelimiters + &#x27;)&#x27;);
        this.PATTERN_SCALAR_BY_DELIMITERS[joinedDelimiters] = pattern;
      }
      if (match = pattern.exec(scalar.slice(i))) {
        output = match[1];
        i += output.length;
      } else {
        throw new ParseException(&#x27;Malformed inline YAML string (&#x27; + scalar + &#x27;).&#x27;);
      }
    }
    if (evaluate) {
      output = this.evaluateScalar(output, context);
    }
  }
  context.i = i;
  return output;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      ++context.i;
      break;
    case &#x27;{&#x27;:
      result = this.parseMapping(value, context);
      ++context.i;
      break;
    default:
      result = this.<span class="apidocCodeKeywordSpan">parseScalar</span>(value, null, [&#x27;&#x22;&#x27;, &#x22;&#x27;&#x22;],
context);
  }
  if (this.PATTERN_TRAILING_COMMENTS.replace(value.slice(context.i), &#x27;&#x27;) !== &#x27;&#x27;) {
    throw new ParseException(&#x27;Unexpected characters near &#x22;&#x27; + value.slice(context.i) + &#x27;&#x22;.&#x27;);
  }
  return result;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Inline.parseSequence" id="apidoc.element.yamljs.Inline.parseSequence">
        function <span class="apidocSignatureSpan">yamljs.Inline.</span>parseSequence
        <span class="apidocSignatureSpan">(sequence, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseSequence = function (sequence, context) {
  var e, i, isQuoted, len, output, ref, value;
  output = [];
  len = sequence.length;
  i = context.i;
  i += 1;
  while (i &#x3c; len) {
    context.i = i;
    switch (sequence.charAt(i)) {
      case &#x27;[&#x27;:
        output.push(this.parseSequence(sequence, context));
        i = context.i;
        break;
      case &#x27;{&#x27;:
        output.push(this.parseMapping(sequence, context));
        i = context.i;
        break;
      case &#x27;]&#x27;:
        return output;
      case &#x27;,&#x27;:
      case &#x27; &#x27;:
      case &#x22;\n&#x22;:
        break;
      default:
        isQuoted = ((ref = sequence.charAt(i)) === &#x27;&#x22;&#x27; || ref === &#x22;&#x27;&#x22;);
        value = this.parseScalar(sequence, [&#x27;,&#x27;, &#x27;]&#x27;], [&#x27;&#x22;&#x27;, &#x22;&#x27;&#x22;], context);
        i = context.i;
        if (!isQuoted &#x26;&#x26; typeof value === &#x27;string&#x27; &#x26;&#x26; (value.indexOf(&#x27;: &#x27;) !== -1 || value.indexOf(&#x22;:\n&#x22;) !== -1)) {
          try {
            value = this.parseMapping(&#x27;{&#x27; + value + &#x27;}&#x27;);
          } catch (error) {
            e = error;
          }
        }
        output.push(value);
        --i;
    }
    ++i;
  }
  throw new ParseMore(&#x27;Malformed inline YAML string &#x27; + sequence);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
context = {
  exceptionOnInvalidType: exceptionOnInvalidType,
  objectDecoder: objectDecoder,
  i: 0
};
switch (value.charAt(0)) {
  case &#x27;[&#x27;:
    result = this.<span class="apidocCodeKeywordSpan">parseSequence</span>(value, context);
    ++context.i;
    break;
  case &#x27;{&#x27;:
    result = this.parseMapping(value, context);
    ++context.i;
    break;
  default:
...</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yamljs.Parser" id="apidoc.module.yamljs.Parser">module yamljs.Parser</a></h1>


    <h2>
        <a href="#apidoc.element.yamljs.Parser.Parser" id="apidoc.element.yamljs.Parser.Parser">
        function <span class="apidocSignatureSpan">yamljs.</span>Parser
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(offset) {
  this.offset = offset != null ? offset : 0;
  this.lines = [];
  this.currentLineNb = -1;
  this.currentLine = &#x27;&#x27;;
  this.refs = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yamljs.Parser.prototype" id="apidoc.module.yamljs.Parser.prototype">module yamljs.Parser.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.yamljs.Parser.prototype.cleanup" id="apidoc.element.yamljs.Parser.prototype.cleanup">
        function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>cleanup
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cleanup = function (value) {
  var count, i, indent, j, l, len, len1, line, lines, ref, ref1, ref2, smallestIndent, trimmedValue;
  if (value.indexOf(&#x22;\r&#x22;) !== -1) {
    value = value.split(&#x22;\r\n&#x22;).join(&#x22;\n&#x22;).split(&#x22;\r&#x22;).join(&#x22;\n&#x22;);
  }
  count = 0;
  ref = this.PATTERN_YAML_HEADER.replaceAll(value, &#x27;&#x27;), value = ref[0], count = ref[1];
  this.offset += count;
  ref1 = this.PATTERN_LEADING_COMMENTS.replaceAll(value, &#x27;&#x27;, 1), trimmedValue = ref1[0], count = ref1[1];
  if (count === 1) {
    this.offset += Utils.subStrCount(value, &#x22;\n&#x22;) - Utils.subStrCount(trimmedValue, &#x22;\n&#x22;);
    value = trimmedValue;
  }
  ref2 = this.PATTERN_DOCUMENT_MARKER_START.replaceAll(value, &#x27;&#x27;, 1), trimmedValue = ref2[0], count = ref2[1];
  if (count === 1) {
    this.offset += Utils.subStrCount(value, &#x22;\n&#x22;) - Utils.subStrCount(trimmedValue, &#x22;\n&#x22;);
    value = trimmedValue;
    value = this.PATTERN_DOCUMENT_MARKER_END.replace(value, &#x27;&#x27;);
  }
  lines = value.split(&#x22;\n&#x22;);
  smallestIndent = -1;
  for (j = 0, len = lines.length; j &#x3c; len; j++) {
    line = lines[j];
    if (Utils.trim(line, &#x27; &#x27;).length === 0) {
      continue;
    }
    indent = line.length - Utils.ltrim(line).length;
    if (smallestIndent === -1 || indent &#x3c; smallestIndent) {
      smallestIndent = indent;
    }
  }
  if (smallestIndent &#x3e; 0) {
    for (i = l = 0, len1 = lines.length; l &#x3c; len1; i = ++l) {
      line = lines[i];
      lines[i] = line.slice(smallestIndent);
    }
    value = lines.join(&#x22;\n&#x22;);
  }
  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  exceptionOnInvalidType = false;
}
if (objectDecoder == null) {
  objectDecoder = null;
}
this.currentLineNb = -1;
this.currentLine = &#x27;&#x27;;
this.lines = this.<span class="apidocCodeKeywordSpan">cleanup</span>(value).split(&#x22;\n&#x22;);
data = null;
context = this.CONTEXT_NONE;
allowOverwrite = false;
while (this.moveToNextLine()) {
  if (this.isCurrentLineEmpty()) {
    continue;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Parser.prototype.getCurrentLineIndentation" id="apidoc.element.yamljs.Parser.prototype.getCurrentLineIndentation">
        function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>getCurrentLineIndentation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCurrentLineIndentation = function () {
  return this.currentLine.length - Utils.ltrim(this.currentLine, &#x27; &#x27;).length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
} else {
  if (((ref = values.leadspaces) != null ? ref.length : void 0) &#x26;&#x26; (matches = this.PATTERN_COMPACT_NOTATION.exec(values
.value))) {
    c = this.getRealCurrentLineNb();
    parser = new Parser(c);
    parser.refs = this.refs;
    block = values.value;
    indent = this.<span class="apidocCodeKeywordSpan">getCurrentLineIndentation</span>();
    if (this.isNextLineIndented(false)) {
      block += &#x22;\n&#x22; + this.getNextEmbedBlock(indent + values.leadspaces.length + 1, true);
    }
    data.push(parser.parse(block, exceptionOnInvalidType, objectDecoder));
  } else {
    data.push(this.parseValue(values.value, exceptionOnInvalidType, objectDecoder));
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Parser.prototype.getNextEmbedBlock" id="apidoc.element.yamljs.Parser.prototype.getNextEmbedBlock">
        function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>getNextEmbedBlock
        <span class="apidocSignatureSpan">(indentation, includeUnindentedCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNextEmbedBlock = function (indentation, includeUnindentedCollection) {
  var data, indent, isItUnindentedCollection, newIndent, removeComments, removeCommentsPattern, unindentedEmbedBlock;
  if (indentation == null) {
    indentation = null;
  }
  if (includeUnindentedCollection == null) {
    includeUnindentedCollection = false;
  }
  this.moveToNextLine();
  if (indentation == null) {
    newIndent = this.getCurrentLineIndentation();
    unindentedEmbedBlock = this.isStringUnIndentedCollectionItem(this.currentLine);
    if (!(this.isCurrentLineEmpty()) &#x26;&#x26; 0 === newIndent &#x26;&#x26; !unindentedEmbedBlock) {
      throw new ParseException(&#x27;Indentation problem.&#x27;, this.getRealCurrentLineNb() + 1, this.currentLine);
    }
  } else {
    newIndent = indentation;
  }
  data = [this.currentLine.slice(newIndent)];
  if (!includeUnindentedCollection) {
    isItUnindentedCollection = this.isStringUnIndentedCollectionItem(this.currentLine);
  }
  removeCommentsPattern = this.PATTERN_FOLDED_SCALAR_END;
  removeComments = !removeCommentsPattern.test(this.currentLine);
  while (this.moveToNextLine()) {
    indent = this.getCurrentLineIndentation();
    if (indent === newIndent) {
      removeComments = !removeCommentsPattern.test(this.currentLine);
    }
    if (removeComments &#x26;&#x26; this.isCurrentLineComment()) {
      continue;
    }
    if (this.isCurrentLineBlank()) {
      data.push(this.currentLine.slice(newIndent));
      continue;
    }
    if (isItUnindentedCollection &#x26;&#x26; !this.isStringUnIndentedCollectionItem(this.currentLine) &#x26;&#x26; indent === newIndent) {
      this.moveToPreviousLine();
      break;
    }
    if (indent &#x3e;= newIndent) {
      data.push(this.currentLine.slice(newIndent));
    } else if (Utils.ltrim(this.currentLine).charAt(0) === &#x27;#&#x27;) {

    } else if (0 === indent) {
      this.moveToPreviousLine();
      break;
    } else {
      throw new ParseException(&#x27;Indentation problem.&#x27;, this.getRealCurrentLineNb() + 1, this.currentLine);
    }
  }
  return data.join(&#x22;\n&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  values.value = matches.value;
}
if (!(values.value != null) || &#x27;&#x27; === Utils.trim(values.value, &#x27; &#x27;) || Utils.ltrim(values.value, &#x27; &#x27
;).indexOf(&#x27;#&#x27;) === 0) {
  if (this.currentLineNb &#x3c; this.lines.length - 1 &#x26;&#x26; !this.isNextLineUnIndentedCollection()) {
    c = this.getRealCurrentLineNb() + 1;
    parser = new Parser(c);
    parser.refs = this.refs;
    data.push(parser.parse(this.<span class="apidocCodeKeywordSpan">getNextEmbedBlock</span>(null, true), exceptionOnInvalidType
, objectDecoder));
  } else {
    data.push(null);
  }
} else {
  if (((ref = values.leadspaces) != null ? ref.length : void 0) &#x26;&#x26; (matches = this.PATTERN_COMPACT_NOTATION.exec(values
.value))) {
    c = this.getRealCurrentLineNb();
    parser = new Parser(c);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Parser.prototype.getRealCurrentLineNb" id="apidoc.element.yamljs.Parser.prototype.getRealCurrentLineNb">
        function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>getRealCurrentLineNb
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRealCurrentLineNb = function () {
  return this.currentLineNb + this.offset;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
context = this.CONTEXT_NONE;
allowOverwrite = false;
while (this.moveToNextLine()) {
  if (this.isCurrentLineEmpty()) {
    continue;
  }
  if (&#x22;\t&#x22; === this.currentLine[0]) {
    throw new ParseException(&#x27;A YAML file cannot contain tabs as indentation.&#x27;, this.<span class="apidocCodeKeywordSpan
">getRealCurrentLineNb</span>() + 1, this.currentLine);
  }
  isRef = mergeNode = false;
  if (values = this.PATTERN_SEQUENCE_ITEM.exec(this.currentLine)) {
    if (this.CONTEXT_MAPPING === context) {
      throw new ParseException(&#x27;You cannot define a sequence item when in a mapping&#x27;);
    }
    context = this.CONTEXT_SEQUENCE;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Parser.prototype.isCurrentLineBlank" id="apidoc.element.yamljs.Parser.prototype.isCurrentLineBlank">
        function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>isCurrentLineBlank
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCurrentLineBlank = function () {
  return &#x27;&#x27; === Utils.trim(this.currentLine, &#x27; &#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
indent = this.getCurrentLineIndentation();
if (indent === newIndent) {
  removeComments = !removeCommentsPattern.test(this.currentLine);
}
if (removeComments &#x26;&#x26; this.isCurrentLineComment()) {
  continue;
}
if (this.<span class="apidocCodeKeywordSpan">isCurrentLineBlank</span>()) {
  data.push(this.currentLine.slice(newIndent));
  continue;
}
if (isItUnindentedCollection &#x26;&#x26; !this.isStringUnIndentedCollectionItem(this.currentLine) &#x26;&#x26; indent === newIndent
) {
  this.moveToPreviousLine();
  break;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Parser.prototype.isCurrentLineComment" id="apidoc.element.yamljs.Parser.prototype.isCurrentLineComment">
        function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>isCurrentLineComment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCurrentLineComment = function () {
  var ltrimmedLine;
  ltrimmedLine = Utils.ltrim(this.currentLine, &#x27; &#x27;);
  return ltrimmedLine.charAt(0) === &#x27;#&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
removeCommentsPattern = this.PATTERN_FOLDED_SCALAR_END;
removeComments = !removeCommentsPattern.test(this.currentLine);
while (this.moveToNextLine()) {
  indent = this.getCurrentLineIndentation();
  if (indent === newIndent) {
    removeComments = !removeCommentsPattern.test(this.currentLine);
  }
  if (removeComments &#x26;&#x26; this.<span class="apidocCodeKeywordSpan">isCurrentLineComment</span>()) {
    continue;
  }
  if (this.isCurrentLineBlank()) {
    data.push(this.currentLine.slice(newIndent));
    continue;
  }
  if (isItUnindentedCollection &#x26;&#x26; !this.isStringUnIndentedCollectionItem(this.currentLine) &#x26;&#x26; indent === newIndent
) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Parser.prototype.isCurrentLineEmpty" id="apidoc.element.yamljs.Parser.prototype.isCurrentLineEmpty">
        function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>isCurrentLineEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCurrentLineEmpty = function () {
  var trimmedLine;
  trimmedLine = Utils.trim(this.currentLine, &#x27; &#x27;);
  return trimmedLine.length === 0 || trimmedLine.charAt(0) === &#x27;#&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.currentLineNb = -1;
this.currentLine = &#x27;&#x27;;
this.lines = this.cleanup(value).split(&#x22;\n&#x22;);
data = null;
context = this.CONTEXT_NONE;
allowOverwrite = false;
while (this.moveToNextLine()) {
  if (this.<span class="apidocCodeKeywordSpan">isCurrentLineEmpty</span>()) {
    continue;
  }
  if (&#x22;\t&#x22; === this.currentLine[0]) {
    throw new ParseException(&#x27;A YAML file cannot contain tabs as indentation.&#x27;, this.getRealCurrentLineNb() + 1, this.
currentLine);
  }
  isRef = mergeNode = false;
  if (values = this.PATTERN_SEQUENCE_ITEM.exec(this.currentLine)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Parser.prototype.isNextLineIndented" id="apidoc.element.yamljs.Parser.prototype.isNextLineIndented">
        function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>isNextLineIndented
        <span class="apidocSignatureSpan">(ignoreComments)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNextLineIndented = function (ignoreComments) {
  var EOF, currentIndentation, ret;
  if (ignoreComments == null) {
    ignoreComments = true;
  }
  currentIndentation = this.getCurrentLineIndentation();
  EOF = !this.moveToNextLine();
  if (ignoreComments) {
    while (!EOF &#x26;&#x26; this.isCurrentLineEmpty()) {
      EOF = !this.moveToNextLine();
    }
  } else {
    while (!EOF &#x26;&#x26; this.isCurrentLineBlank()) {
      EOF = !this.moveToNextLine();
    }
  }
  if (EOF) {
    return false;
  }
  ret = false;
  if (this.getCurrentLineIndentation() &#x3e; currentIndentation) {
    ret = true;
  }
  this.moveToPreviousLine();
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  if (((ref = values.leadspaces) != null ? ref.length : void 0) &#x26;&#x26; (matches = this.PATTERN_COMPACT_NOTATION.exec(values
.value))) {
    c = this.getRealCurrentLineNb();
    parser = new Parser(c);
    parser.refs = this.refs;
    block = values.value;
    indent = this.getCurrentLineIndentation();
    if (this.<span class="apidocCodeKeywordSpan">isNextLineIndented</span>(false)) {
      block += &#x22;\n&#x22; + this.getNextEmbedBlock(indent + values.leadspaces.length + 1, true);
    }
    data.push(parser.parse(block, exceptionOnInvalidType, objectDecoder));
  } else {
    data.push(this.parseValue(values.value, exceptionOnInvalidType, objectDecoder));
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Parser.prototype.isNextLineUnIndentedCollection" id="apidoc.element.yamljs.Parser.prototype.isNextLineUnIndentedCollection">
        function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>isNextLineUnIndentedCollection
        <span class="apidocSignatureSpan">(currentIndentation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNextLineUnIndentedCollection = function (currentIndentation) {
  var notEOF, ret;
  if (currentIndentation == null) {
    currentIndentation = null;
  }
  if (currentIndentation == null) {
    currentIndentation = this.getCurrentLineIndentation();
  }
  notEOF = this.moveToNextLine();
  while (notEOF &#x26;&#x26; this.isCurrentLineEmpty()) {
    notEOF = this.moveToNextLine();
  }
  if (false === notEOF) {
    return false;
  }
  ret = false;
  if (this.getCurrentLineIndentation() === currentIndentation &#x26;&#x26; this.isStringUnIndentedCollectionItem(this.currentLine)) {
    ret = true;
  }
  this.moveToPreviousLine();
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  data = [];
}
if ((values.value != null) &#x26;&#x26; (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {
  isRef = matches.ref;
  values.value = matches.value;
}
if (!(values.value != null) || &#x27;&#x27; === Utils.trim(values.value, &#x27; &#x27;) || Utils.ltrim(values.value, &#x27; &#x27
;).indexOf(&#x27;#&#x27;) === 0) {
  if (this.currentLineNb &#x3c; this.lines.length - 1 &#x26;&#x26; !this.<span class="apidocCodeKeywordSpan">isNextLineUnIndentedCollection
</span>()) {
    c = this.getRealCurrentLineNb() + 1;
    parser = new Parser(c);
    parser.refs = this.refs;
    data.push(parser.parse(this.getNextEmbedBlock(null, true), exceptionOnInvalidType, objectDecoder));
  } else {
    data.push(null);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Parser.prototype.isStringUnIndentedCollectionItem" id="apidoc.element.yamljs.Parser.prototype.isStringUnIndentedCollectionItem">
        function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>isStringUnIndentedCollectionItem
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isStringUnIndentedCollectionItem = function () {
  return this.currentLine === &#x27;-&#x27; || this.currentLine.slice(0, 2) === &#x27;- &#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (includeUnindentedCollection == null) {
  includeUnindentedCollection = false;
}
this.moveToNextLine();
if (indentation == null) {
  newIndent = this.getCurrentLineIndentation();
  unindentedEmbedBlock = this.<span class="apidocCodeKeywordSpan">isStringUnIndentedCollectionItem</span>(this.currentLine);
  if (!(this.isCurrentLineEmpty()) &#x26;&#x26; 0 === newIndent &#x26;&#x26; !unindentedEmbedBlock) {
    throw new ParseException(&#x27;Indentation problem.&#x27;, this.getRealCurrentLineNb() + 1, this.currentLine);
  }
} else {
  newIndent = indentation;
}
data = [this.currentLine.slice(newIndent)];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Parser.prototype.moveToNextLine" id="apidoc.element.yamljs.Parser.prototype.moveToNextLine">
        function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>moveToNextLine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">moveToNextLine = function () {
  if (this.currentLineNb &#x3e;= this.lines.length - 1) {
    return false;
  }
  this.currentLine = this.lines[++this.currentLineNb];
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
this.currentLineNb = -1;
this.currentLine = &#x27;&#x27;;
this.lines = this.cleanup(value).split(&#x22;\n&#x22;);
data = null;
context = this.CONTEXT_NONE;
allowOverwrite = false;
while (this.<span class="apidocCodeKeywordSpan">moveToNextLine</span>()) {
  if (this.isCurrentLineEmpty()) {
    continue;
  }
  if (&#x22;\t&#x22; === this.currentLine[0]) {
    throw new ParseException(&#x27;A YAML file cannot contain tabs as indentation.&#x27;, this.getRealCurrentLineNb() + 1, this.
currentLine);
  }
  isRef = mergeNode = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Parser.prototype.moveToPreviousLine" id="apidoc.element.yamljs.Parser.prototype.moveToPreviousLine">
        function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>moveToPreviousLine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">moveToPreviousLine = function () {
  this.currentLine = this.lines[--this.currentLineNb];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  continue;
}
if (this.isCurrentLineBlank()) {
  data.push(this.currentLine.slice(newIndent));
  continue;
}
if (isItUnindentedCollection &#x26;&#x26; !this.isStringUnIndentedCollectionItem(this.currentLine) &#x26;&#x26; indent === newIndent
) {
  this.<span class="apidocCodeKeywordSpan">moveToPreviousLine</span>();
  break;
}
if (indent &#x3e;= newIndent) {
  data.push(this.currentLine.slice(newIndent));
} else if (Utils.ltrim(this.currentLine).charAt(0) === &#x27;#&#x27;) {

} else if (0 === indent) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Parser.prototype.parse" id="apidoc.element.yamljs.Parser.prototype.parse">
        function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>parse
        <span class="apidocSignatureSpan">(value, exceptionOnInvalidType, objectDecoder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (value, exceptionOnInvalidType, objectDecoder) {
  var alias, allowOverwrite, block, c, context, data, e, first, i, indent, isRef, j, k, key, l, lastKey, len, len1, len2, len3,
lineCount, m, matches, mergeNode, n, name, parsed, parsedItem, parser, ref, ref1, ref2, refName, refValue, val, values;
  if (exceptionOnInvalidType == null) {
    exceptionOnInvalidType = false;
  }
  if (objectDecoder == null) {
    objectDecoder = null;
  }
  this.currentLineNb = -1;
  this.currentLine = &#x27;&#x27;;
  this.lines = this.cleanup(value).split(&#x22;\n&#x22;);
  data = null;
  context = this.CONTEXT_NONE;
  allowOverwrite = false;
  while (this.moveToNextLine()) {
    if (this.isCurrentLineEmpty()) {
      continue;
    }
    if (&#x22;\t&#x22; === this.currentLine[0]) {
      throw new ParseException(&#x27;A YAML file cannot contain tabs as indentation.&#x27;, this.getRealCurrentLineNb() + 1, this.currentLine
);
    }
    isRef = mergeNode = false;
    if (values = this.PATTERN_SEQUENCE_ITEM.exec(this.currentLine)) {
      if (this.CONTEXT_MAPPING === context) {
        throw new ParseException(&#x27;You cannot define a sequence item when in a mapping&#x27;);
      }
      context = this.CONTEXT_SEQUENCE;
      if (data == null) {
        data = [];
      }
      if ((values.value != null) &#x26;&#x26; (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {
        isRef = matches.ref;
        values.value = matches.value;
      }
      if (!(values.value != null) || &#x27;&#x27; === Utils.trim(values.value, &#x27; &#x27;) || Utils.ltrim(values.value, &#x27; &#x27;).indexOf(&#x27;#&#x27;) === 0) {
        if (this.currentLineNb &#x3c; this.lines.length - 1 &#x26;&#x26; !this.isNextLineUnIndentedCollection()) {
          c = this.getRealCurrentLineNb() + 1;
          parser = new Parser(c);
          parser.refs = this.refs;
          data.push(parser.parse(this.getNextEmbedBlock(null, true), exceptionOnInvalidType, objectDecoder));
        } else {
          data.push(null);
        }
      } else {
        if (((ref = values.leadspaces) != null ? ref.length : void 0) &#x26;&#x26; (matches = this.PATTERN_COMPACT_NOTATION.exec(values.value
))) {
          c = this.getRealCurrentLineNb();
          parser = new Parser(c);
          parser.refs = this.refs;
          block = values.value;
          indent = this.getCurrentLineIndentation();
          if (this.isNextLineIndented(false)) {
            block += &#x22;\n&#x22; + this.getNextEmbedBlock(indent + values.leadspaces.length + 1, true);
          }
          data.push(parser.parse(block, exceptionOnInvalidType, objectDecoder));
        } else {
          data.push(this.parseValue(values.value, exceptionOnInvalidType, objectDecoder));
        }
      }
    } else if ((values = this.PATTERN_MAPPING_ITEM.exec(this.currentLine)) &#x26;&#x26; values.key.indexOf(&#x27; #&#x27;) === -1) {
      if (this.CONTEXT_SEQUENCE === context) {
        throw new ParseException(&#x27;You cannot define a mapping item when in a sequence&#x27;);
      }
      context = this.CONTEXT_MAPPING;
      if (data == null) {
        data = {};
      }
      Inline.configure(exceptionOnInvalidType, objectDecoder);
      try {
        key = Inline.parseScalar(values.key);
      } catch (error) {
        e = error;
        e.parsedLine = this.getRealCurrentLineNb() + 1;
        e.snippet = this.currentLine;
        throw e;
      }
      if (&#x27;&#x3c;&#x3c;&#x27; === key) {
        mergeNode = true;
        allowOverwrite = true;
        if (((ref1 = values.value) != null ? ref1.indexOf(&#x27;*&#x27;) : void 0) === 0) {
          refName = values.value.slice(1);
          if (this.refs[refName] == null) {
            throw new ParseException(&#x27;Reference &#x22;&#x27; + refName + &#x27;&#x22; does not exist.&#x27;, this.getRealCurrentLineNb() + 1, this.currentLine
);
          }
          refValue = this.refs[refName];
          if (typeof refValue !== &#x27;object&#x27;) {
            throw new ParseException(&#x27;YAML merge keys used with a scalar value instead of an object.&#x27;, this.getRealCurrentLineNb
() + 1, this.currentLine);
          }
          if (refValue instanceof Array) {
            for (i = j = 0, len = refValue.length; j &#x3c; len; i = ++j) {
              value = refValue[i];
              if (data[name = Strin ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
``` html
&#x3c;script type=&#x22;text/javascript&#x22; src=&#x22;yaml.js&#x22;&#x3e;&#x3c;/script&#x3e;
```

Parse yaml string:

``` js
nativeObject = YAML.<span class="apidocCodeKeywordSpan">parse</span>(yamlString);
```

Dump native object into yaml string:

``` js
yamlString = YAML.stringify(nativeObject[, inline /* @integer depth to start using inline notation at */[, spaces /* @integer number
 of spaces to use for indentation */] ]);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Parser.prototype.parseFoldedScalar" id="apidoc.element.yamljs.Parser.prototype.parseFoldedScalar">
        function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>parseFoldedScalar
        <span class="apidocSignatureSpan">(separator, indicator, indentation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseFoldedScalar = function (separator, indicator, indentation) {
  var isCurrentLineBlank, j, len, line, matches, newText, notEOF, pattern, ref, text;
  if (indicator == null) {
    indicator = &#x27;&#x27;;
  }
  if (indentation == null) {
    indentation = 0;
  }
  notEOF = this.moveToNextLine();
  if (!notEOF) {
    return &#x27;&#x27;;
  }
  isCurrentLineBlank = this.isCurrentLineBlank();
  text = &#x27;&#x27;;
  while (notEOF &#x26;&#x26; isCurrentLineBlank) {
    if (notEOF = this.moveToNextLine()) {
      text += &#x22;\n&#x22;;
      isCurrentLineBlank = this.isCurrentLineBlank();
    }
  }
  if (0 === indentation) {
    if (matches = this.PATTERN_INDENT_SPACES.exec(this.currentLine)) {
      indentation = matches[0].length;
    }
  }
  if (indentation &#x3e; 0) {
    pattern = this.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation];
    if (pattern == null) {
      pattern = new Pattern(&#x27;^ {&#x27; + indentation + &#x27;}(.*)$&#x27;);
      Parser.prototype.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation] = pattern;
    }
    while (notEOF &#x26;&#x26; (isCurrentLineBlank || (matches = pattern.exec(this.currentLine)))) {
      if (isCurrentLineBlank) {
        text += this.currentLine.slice(indentation);
      } else {
        text += matches[1];
      }
      if (notEOF = this.moveToNextLine()) {
        text += &#x22;\n&#x22;;
        isCurrentLineBlank = this.isCurrentLineBlank();
      }
    }
  } else if (notEOF) {
    text += &#x22;\n&#x22;;
  }
  if (notEOF) {
    this.moveToPreviousLine();
  }
  if (&#x27;&#x3e;&#x27; === separator) {
    newText = &#x27;&#x27;;
    ref = text.split(&#x22;\n&#x22;);
    for (j = 0, len = ref.length; j &#x3c; len; j++) {
      line = ref[j];
      if (line.length === 0 || line.charAt(0) === &#x27; &#x27;) {
        newText = Utils.rtrim(newText, &#x27; &#x27;) + line + &#x22;\n&#x22;;
      } else {
        newText += line + &#x27; &#x27;;
      }
    }
    text = newText;
  }
  if (&#x27;+&#x27; !== indicator) {
    text = Utils.rtrim(text);
  }
  if (&#x27;&#x27; === indicator) {
    text = this.PATTERN_TRAILING_LINES.replace(text, &#x22;\n&#x22;);
  } else if (&#x27;-&#x27; === indicator) {
    text = this.PATTERN_TRAILING_LINES.replace(text, &#x27;&#x27;);
  }
  return text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (matches = this.PATTERN_FOLDED_SCALAR_ALL.exec(value)) {
  modifiers = (ref = matches.modifiers) != null ? ref : &#x27;&#x27;;
  foldedIndent = Math.abs(parseInt(modifiers));
  if (isNaN(foldedIndent)) {
    foldedIndent = 0;
  }
  val = this.<span class="apidocCodeKeywordSpan">parseFoldedScalar</span>(matches.separator, this.PATTERN_DECIMAL.replace(modifiers
, &#x27;&#x27;), foldedIndent);
  if (matches.type != null) {
    Inline.configure(exceptionOnInvalidType, objectDecoder);
    return Inline.parseScalar(matches.type + &#x27; &#x27; + val);
  } else {
    return val;
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Parser.prototype.parseValue" id="apidoc.element.yamljs.Parser.prototype.parseValue">
        function <span class="apidocSignatureSpan">yamljs.Parser.prototype.</span>parseValue
        <span class="apidocSignatureSpan">(value, exceptionOnInvalidType, objectDecoder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseValue = function (value, exceptionOnInvalidType, objectDecoder) {
  var e, foldedIndent, matches, modifiers, pos, ref, ref1, val;
  if (0 === value.indexOf(&#x27;*&#x27;)) {
    pos = value.indexOf(&#x27;#&#x27;);
    if (pos !== -1) {
      value = value.substr(1, pos - 2);
    } else {
      value = value.slice(1);
    }
    if (this.refs[value] === void 0) {
      throw new ParseException(&#x27;Reference &#x22;&#x27; + value + &#x27;&#x22; does not exist.&#x27;, this.currentLine);
    }
    return this.refs[value];
  }
  if (matches = this.PATTERN_FOLDED_SCALAR_ALL.exec(value)) {
    modifiers = (ref = matches.modifiers) != null ? ref : &#x27;&#x27;;
    foldedIndent = Math.abs(parseInt(modifiers));
    if (isNaN(foldedIndent)) {
      foldedIndent = 0;
    }
    val = this.parseFoldedScalar(matches.separator, this.PATTERN_DECIMAL.replace(modifiers, &#x27;&#x27;), foldedIndent);
    if (matches.type != null) {
      Inline.configure(exceptionOnInvalidType, objectDecoder);
      return Inline.parseScalar(matches.type + &#x27; &#x27; + val);
    } else {
      return val;
    }
  }
  if ((ref1 = value.charAt(0)) === &#x27;[&#x27; || ref1 === &#x27;{&#x27; || ref1 === &#x27;&#x22;&#x27; || ref1 === &#x22;&#x27;&#x22;) {
    while (true) {
      try {
        return Inline.parse(value, exceptionOnInvalidType, objectDecoder);
      } catch (error) {
        e = error;
        if (e instanceof ParseMore &#x26;&#x26; this.moveToNextLine()) {
          value += &#x22;\n&#x22; + Utils.trim(this.currentLine, &#x27; &#x27;);
        } else {
          e.parsedLine = this.getRealCurrentLineNb() + 1;
          e.snippet = this.currentLine;
          throw e;
        }
      }
    }
  } else {
    if (this.isNextLineIndented()) {
      value += &#x22;\n&#x22; + this.getNextEmbedBlock();
    }
    return Inline.parse(value, exceptionOnInvalidType, objectDecoder);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      block = values.value;
      indent = this.getCurrentLineIndentation();
      if (this.isNextLineIndented(false)) {
        block += &#x22;\n&#x22; + this.getNextEmbedBlock(indent + values.leadspaces.length + 1, true);
      }
      data.push(parser.parse(block, exceptionOnInvalidType, objectDecoder));
    } else {
      data.push(this.<span class="apidocCodeKeywordSpan">parseValue</span>(values.value, exceptionOnInvalidType, objectDecoder));
    }
  }
} else if ((values = this.PATTERN_MAPPING_ITEM.exec(this.currentLine)) &#x26;&#x26; values.key.indexOf(&#x27; #&#x27;) === -1) {
  if (this.CONTEXT_SEQUENCE === context) {
    throw new ParseException(&#x27;You cannot define a mapping item when in a sequence&#x27;);
  }
  context = this.CONTEXT_MAPPING;
...</pre></li>
    </ul>




































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yamljs.Pattern" id="apidoc.module.yamljs.Pattern">module yamljs.Pattern</a></h1>


    <h2>
        <a href="#apidoc.element.yamljs.Pattern.Pattern" id="apidoc.element.yamljs.Pattern.Pattern">
        function <span class="apidocSignatureSpan">yamljs.</span>Pattern
        <span class="apidocSignatureSpan">(rawRegex, modifiers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pattern(rawRegex, modifiers) {
  var _char, capturingBracketNumber, cleanedRegex, i, len, mapping, name, part, subChar;
  if (modifiers == null) {
    modifiers = &#x27;&#x27;;
  }
  cleanedRegex = &#x27;&#x27;;
  len = rawRegex.length;
  mapping = null;
  capturingBracketNumber = 0;
  i = 0;
  while (i &#x3c; len) {
    _char = rawRegex.charAt(i);
    if (_char === &#x27;\\&#x27;) {
      cleanedRegex += rawRegex.slice(i, +(i + 1) + 1 || 9e9);
      i++;
    } else if (_char === &#x27;(&#x27;) {
      if (i &#x3c; len - 2) {
        part = rawRegex.slice(i, +(i + 2) + 1 || 9e9);
        if (part === &#x27;(?:&#x27;) {
          i += 2;
          cleanedRegex += part;
        } else if (part === &#x27;(?&#x3c;&#x27;) {
          capturingBracketNumber++;
          i += 2;
          name = &#x27;&#x27;;
          while (i + 1 &#x3c; len) {
            subChar = rawRegex.charAt(i + 1);
            if (subChar === &#x27;&#x3e;&#x27;) {
              cleanedRegex += &#x27;(&#x27;;
              i++;
              if (name.length &#x3e; 0) {
                if (mapping == null) {
                  mapping = {};
                }
                mapping[name] = capturingBracketNumber;
              }
              break;
            } else {
              name += subChar;
            }
            i++;
          }
        } else {
          cleanedRegex += _char;
          capturingBracketNumber++;
        }
      } else {
        cleanedRegex += _char;
      }
    } else {
      cleanedRegex += _char;
    }
    i++;
  }
  this.rawRegex = rawRegex;
  this.cleanedRegex = cleanedRegex;
  this.regex = new RegExp(this.cleanedRegex, &#x27;g&#x27; + modifiers.replace(&#x27;g&#x27;, &#x27;&#x27;));
  this.mapping = mapping;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yamljs.Pattern.prototype" id="apidoc.module.yamljs.Pattern.prototype">module yamljs.Pattern.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.yamljs.Pattern.prototype.exec" id="apidoc.element.yamljs.Pattern.prototype.exec">
        function <span class="apidocSignatureSpan">yamljs.Pattern.prototype.</span>exec
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (str) {
  var index, matches, name, ref;
  this.regex.lastIndex = 0;
  matches = this.regex.exec(str);
  if (matches == null) {
    return null;
  }
  if (this.mapping != null) {
    ref = this.mapping;
    for (name in ref) {
      index = ref[name];
      matches[name] = matches[index];
    }
  }
  return matches;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  joinedDelimiters = delimiters.join(&#x27;|&#x27;);
  pattern = this.PATTERN_SCALAR_BY_DELIMITERS[joinedDelimiters];
  if (pattern == null) {
    pattern = new Pattern(&#x27;^(.+?)(&#x27; + joinedDelimiters + &#x27;)&#x27;);
    this.PATTERN_SCALAR_BY_DELIMITERS[joinedDelimiters] = pattern;
  }
  if (match = pattern.<span class="apidocCodeKeywordSpan">exec</span>(scalar.slice(i))) {
    output = match[1];
    i += output.length;
  } else {
    throw new ParseException(&#x27;Malformed inline YAML string (&#x27; + scalar + &#x27;).&#x27;);
  }
}
if (evaluate) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Pattern.prototype.replace" id="apidoc.element.yamljs.Pattern.prototype.replace">
        function <span class="apidocSignatureSpan">yamljs.Pattern.prototype.</span>replace
        <span class="apidocSignatureSpan">(str, replacement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function (str, replacement) {
  this.regex.lastIndex = 0;
  return str.replace(this.regex, replacement);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Escaper.requiresDoubleQuoting = function(value) {
  return this.PATTERN_CHARACTERS_TO_ESCAPE.test(value);
};

Escaper.escapeWithDoubleQuotes = function(value) {
  var result;
  result = this.PATTERN_MAPPING_ESCAPEES.<span class="apidocCodeKeywordSpan">replace</span>(value, (function(_this) {
    return function(str) {
      return _this.MAPPING_ESCAPEES_TO_ESCAPED[str];
    };
  })(this));
  return &#x27;&#x22;&#x27; + result + &#x27;&#x22;&#x27;;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Pattern.prototype.replaceAll" id="apidoc.element.yamljs.Pattern.prototype.replaceAll">
        function <span class="apidocSignatureSpan">yamljs.Pattern.prototype.</span>replaceAll
        <span class="apidocSignatureSpan">(str, replacement, limit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replaceAll = function (str, replacement, limit) {
  var count;
  if (limit == null) {
    limit = 0;
  }
  this.regex.lastIndex = 0;
  count = 0;
  while (this.regex.test(str) &#x26;&#x26; (limit === 0 || count &#x3c; limit)) {
    this.regex.lastIndex = 0;
    str = str.replace(this.regex, replacement);
    count++;
  }
  return [str, count];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  Parser.prototype.cleanup = function(value) {
var count, i, indent, j, l, len, len1, line, lines, ref, ref1, ref2, smallestIndent, trimmedValue;
if (value.indexOf(&#x22;\r&#x22;) !== -1) {
  value = value.split(&#x22;\r\n&#x22;).join(&#x22;\n&#x22;).split(&#x22;\r&#x22;).join(&#x22;\n&#x22;);
}
count = 0;
ref = this.PATTERN_YAML_HEADER.<span class="apidocCodeKeywordSpan">replaceAll</span>(value, &#x27;&#x27;), value = ref[0], count
 = ref[1];
this.offset += count;
ref1 = this.PATTERN_LEADING_COMMENTS.replaceAll(value, &#x27;&#x27;, 1), trimmedValue = ref1[0], count = ref1[1];
if (count === 1) {
  this.offset += Utils.subStrCount(value, &#x22;\n&#x22;) - Utils.subStrCount(trimmedValue, &#x22;\n&#x22;);
  value = trimmedValue;
}
ref2 = this.PATTERN_DOCUMENT_MARKER_START.replaceAll(value, &#x27;&#x27;, 1), trimmedValue = ref2[0], count = ref2[1];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Pattern.prototype.test" id="apidoc.element.yamljs.Pattern.prototype.test">
        function <span class="apidocSignatureSpan">yamljs.Pattern.prototype.</span>test
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">test = function (str) {
  this.regex.lastIndex = 0;
  return this.regex.test(str);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Escaper.PATTERN_CHARACTERS_TO_ESCAPE = new Pattern(&#x27;[\\x00-\\x1f]|\xc2\x85|\xc2\xa0|\xe2\x80\xa8|\xe2\x80\xa9&#x27;);

Escaper.PATTERN_MAPPING_ESCAPEES = new Pattern(Escaper.LIST_ESCAPEES.join(&#x27;|&#x27;).split(&#x27;\\&#x27;).join(&#x27;\\\\&#
x27;));

Escaper.PATTERN_SINGLE_QUOTING = new Pattern(&#x27;[\\s\&#x27;&#x22;:{}[\\],&#x26;*#?]|^[-?|&#x3c;&#x3e;=!%@`]&#x27;);

Escaper.requiresDoubleQuoting = function(value) {
  return this.PATTERN_CHARACTERS_TO_ESCAPE.<span class="apidocCodeKeywordSpan">test</span>(value);
};

Escaper.escapeWithDoubleQuotes = function(value) {
  var result;
  result = this.PATTERN_MAPPING_ESCAPEES.replace(value, (function(_this) {
    return function(str) {
      return _this.MAPPING_ESCAPEES_TO_ESCAPED[str];
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yamljs.Unescaper" id="apidoc.module.yamljs.Unescaper">module yamljs.Unescaper</a></h1>


    <h2>
        <a href="#apidoc.element.yamljs.Unescaper.Unescaper" id="apidoc.element.yamljs.Unescaper.Unescaper">
        function <span class="apidocSignatureSpan">yamljs.</span>Unescaper
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Unescaper() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Unescaper.unescapeCharacter" id="apidoc.element.yamljs.Unescaper.unescapeCharacter">
        function <span class="apidocSignatureSpan">yamljs.Unescaper.</span>unescapeCharacter
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unescapeCharacter = function (value) {
  var ch;
  ch = String.fromCharCode;
  switch (value.charAt(1)) {
    case &#x27;0&#x27;:
      return ch(0);
    case &#x27;a&#x27;:
      return ch(7);
    case &#x27;b&#x27;:
      return ch(8);
    case &#x27;t&#x27;:
      return &#x22;\t&#x22;;
    case &#x22;\t&#x22;:
      return &#x22;\t&#x22;;
    case &#x27;n&#x27;:
      return &#x22;\n&#x22;;
    case &#x27;v&#x27;:
      return ch(11);
    case &#x27;f&#x27;:
      return ch(12);
    case &#x27;r&#x27;:
      return ch(13);
    case &#x27;e&#x27;:
      return ch(27);
    case &#x27; &#x27;:
      return &#x27; &#x27;;
    case &#x27;&#x22;&#x27;:
      return &#x27;&#x22;&#x27;;
    case &#x27;/&#x27;:
      return &#x27;/&#x27;;
    case &#x27;\\&#x27;:
      return &#x27;\\&#x27;;
    case &#x27;N&#x27;:
      return ch(0x0085);
    case &#x27;_&#x27;:
      return ch(0x00A0);
    case &#x27;L&#x27;:
      return ch(0x2028);
    case &#x27;P&#x27;:
      return ch(0x2029);
    case &#x27;x&#x27;:
      return Utils.utf8chr(Utils.hexDec(value.substr(2, 2)));
    case &#x27;u&#x27;:
      return Utils.utf8chr(Utils.hexDec(value.substr(2, 4)));
    case &#x27;U&#x27;:
      return Utils.utf8chr(Utils.hexDec(value.substr(2, 8)));
    default:
      return &#x27;&#x27;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return value.replace(/\&#x27;\&#x27;/g, &#x27;\&#x27;&#x27;);
};

Unescaper.unescapeDoubleQuotedString = function(value) {
  if (this._unescapeCallback == null) {
    this._unescapeCallback = (function(_this) {
      return function(str) {
        return _this.<span class="apidocCodeKeywordSpan">unescapeCharacter</span>(str);
      };
    })(this);
  }
  return this.PATTERN_ESCAPED_CHARACTER.replace(value, this._unescapeCallback);
};

Unescaper.unescapeCharacter = function(value) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Unescaper.unescapeDoubleQuotedString" id="apidoc.element.yamljs.Unescaper.unescapeDoubleQuotedString">
        function <span class="apidocSignatureSpan">yamljs.Unescaper.</span>unescapeDoubleQuotedString
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unescapeDoubleQuotedString = function (value) {
  if (this._unescapeCallback == null) {
    this._unescapeCallback = (function(_this) {
      return function(str) {
        return _this.unescapeCharacter(str);
      };
    })(this);
  }
  return this.PATTERN_ESCAPED_CHARACTER.replace(value, this._unescapeCallback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var i, match, output;
  i = context.i;
  if (!(match = this.PATTERN_QUOTED_SCALAR.exec(scalar.slice(i)))) {
    throw new ParseMore(&#x27;Malformed inline YAML string (&#x27; + scalar.slice(i) + &#x27;).&#x27;);
  }
  output = match[0].substr(1, match[0].length - 2);
  if (&#x27;&#x22;&#x27; === scalar.charAt(i)) {
    output = Unescaper.<span class="apidocCodeKeywordSpan">unescapeDoubleQuotedString</span>(output);
  } else {
    output = Unescaper.unescapeSingleQuotedString(output);
  }
  i += match[0].length;
  context.i = i;
  return output;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Unescaper.unescapeSingleQuotedString" id="apidoc.element.yamljs.Unescaper.unescapeSingleQuotedString">
        function <span class="apidocSignatureSpan">yamljs.Unescaper.</span>unescapeSingleQuotedString
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unescapeSingleQuotedString = function (value) {
  return value.replace(/\&#x27;\&#x27;/g, &#x27;\&#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (!(match = this.PATTERN_QUOTED_SCALAR.exec(scalar.slice(i)))) {
    throw new ParseMore(&#x27;Malformed inline YAML string (&#x27; + scalar.slice(i) + &#x27;).&#x27;);
  }
  output = match[0].substr(1, match[0].length - 2);
  if (&#x27;&#x22;&#x27; === scalar.charAt(i)) {
    output = Unescaper.unescapeDoubleQuotedString(output);
  } else {
    output = Unescaper.<span class="apidocCodeKeywordSpan">unescapeSingleQuotedString</span>(output);
  }
  i += match[0].length;
  context.i = i;
  return output;
};

Inline.parseSequence = function(sequence, context) {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yamljs.Utils" id="apidoc.module.yamljs.Utils">module yamljs.Utils</a></h1>


    <h2>
        <a href="#apidoc.element.yamljs.Utils.Utils" id="apidoc.element.yamljs.Utils.Utils">
        function <span class="apidocSignatureSpan">yamljs.</span>Utils
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Utils() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Utils.getStringFromFile" id="apidoc.element.yamljs.Utils.getStringFromFile">
        function <span class="apidocSignatureSpan">yamljs.Utils.</span>getStringFromFile
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getStringFromFile = function (path, callback) {
  var data, fs, j, len1, name, ref, req, xhr;
  if (callback == null) {
    callback = null;
  }
  xhr = null;
  if (typeof window !== &#x22;undefined&#x22; &#x26;&#x26; window !== null) {
    if (window.XMLHttpRequest) {
      xhr = new XMLHttpRequest();
    } else if (window.ActiveXObject) {
      ref = [&#x22;Msxml2.XMLHTTP.6.0&#x22;, &#x22;Msxml2.XMLHTTP.3.0&#x22;, &#x22;Msxml2.XMLHTTP&#x22;, &#x22;Microsoft.XMLHTTP&#x22;];
      for (j = 0, len1 = ref.length; j &#x3c; len1; j++) {
        name = ref[j];
        try {
          xhr = new ActiveXObject(name);
        } catch (error) {}
      }
    }
  }
  if (xhr != null) {
    if (callback != null) {
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          if (xhr.status === 200 || xhr.status === 0) {
            return callback(xhr.responseText);
          } else {
            return callback(null);
          }
        }
      };
      xhr.open(&#x27;GET&#x27;, path, true);
      return xhr.send(null);
    } else {
      xhr.open(&#x27;GET&#x27;, path, false);
      xhr.send(null);
      if (xhr.status === 200 || xhr.status === 0) {
        return xhr.responseText;
      }
      return null;
    }
  } else {
    req = require;
    fs = req(&#x27;fs&#x27;);
    if (callback != null) {
      return fs.readFile(path, function(err, data) {
        if (err) {
          return callback(null);
        } else {
          return callback(String(data));
        }
      });
    } else {
      data = fs.readFileSync(path);
      if (data != null) {
        return String(data);
      }
      return null;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Utils.hexDec" id="apidoc.element.yamljs.Utils.hexDec">
        function <span class="apidocSignatureSpan">yamljs.Utils.</span>hexDec
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hexDec = function (input) {
  this.REGEX_HEXADECIMAL.lastIndex = 0;
  input = this.trim(input);
  if ((input + &#x27;&#x27;).slice(0, 2) === &#x27;0x&#x27;) {
    input = (input + &#x27;&#x27;).slice(2);
  }
  return parseInt((input + &#x27;&#x27;).replace(this.REGEX_HEXADECIMAL, &#x27;&#x27;), 16);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        throw new ParseException(&#x27;Custom object support when parsing a YAML file has been disabled.&#x27;);
      }
      return null;
  }
  break;
case &#x27;0&#x27;:
  if (&#x27;0x&#x27; === scalar.slice(0, 2)) {
    return Utils.<span class="apidocCodeKeywordSpan">hexDec</span>(scalar);
  } else if (Utils.isDigits(scalar)) {
    return Utils.octDec(scalar);
  } else if (Utils.isNumeric(scalar)) {
    return parseFloat(scalar);
  } else {
    return scalar;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Utils.isDigits" id="apidoc.element.yamljs.Utils.isDigits">
        function <span class="apidocSignatureSpan">yamljs.Utils.</span>isDigits
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isDigits = function (input) {
  this.REGEX_DIGITS.lastIndex = 0;
  return this.REGEX_DIGITS.test(input);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
  return this.dumpObject(value);
}
if (type === &#x27;boolean&#x27;) {
  return (value ? &#x27;true&#x27; : &#x27;false&#x27;);
}
if (Utils.<span class="apidocCodeKeywordSpan">isDigits</span>(value)) {
  return (type === &#x27;string&#x27; ? &#x22;&#x27;&#x22; + value + &#x22;&#x27;&#x22; : String(parseInt(value)));
}
if (Utils.isNumeric(value)) {
  return (type === &#x27;string&#x27; ? &#x22;&#x27;&#x22; + value + &#x22;&#x27;&#x22; : String(parseFloat(value)));
}
if (type === &#x27;number&#x27;) {
  return (value === 2e308 ? &#x27;.Inf&#x27; : (value === -2e308 ? &#x27;-.Inf&#x27; : (isNaN(value) ? &#x27;.NaN&#x27; : value)));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Utils.isEmpty" id="apidoc.element.yamljs.Utils.isEmpty">
        function <span class="apidocSignatureSpan">yamljs.Utils.</span>isEmpty
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmpty = function (value) {
  return !value || value === &#x27;&#x27; || value === &#x27;0&#x27; || (value instanceof Array &#x26;&#x26; value.length === 0) || this.isEmptyObject(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  exceptionOnInvalidType = false;
}
if (objectEncoder == null) {
  objectEncoder = null;
}
output = &#x27;&#x27;;
prefix = (indent ? Utils.strRepeat(&#x27; &#x27;, indent) : &#x27;&#x27;);
if (inline &#x3c;= 0 || typeof input !== &#x27;object&#x27; || input instanceof Date || Utils.<span class="apidocCodeKeywordSpan
">isEmpty</span>(input)) {
  output += prefix + Inline.dump(input, exceptionOnInvalidType, objectEncoder);
} else {
  if (input instanceof Array) {
    for (i = 0, len = input.length; i &#x3c; len; i++) {
      value = input[i];
      willBeInlined = inline - 1 &#x3c;= 0 || typeof value !== &#x27;object&#x27; || Utils.isEmpty(value);
      output += prefix + &#x27;-&#x27; + (willBeInlined ? &#x27; &#x27; : &#x22;\n&#x22;) + this.dump(value, inline - 1, (willBeInlined
 ? 0 : indent + this.indentation), exceptionOnInvalidType, objectEncoder) + (willBeInlined ? &#x22;\n&#x22; : &#x27;&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Utils.isEmptyObject" id="apidoc.element.yamljs.Utils.isEmptyObject">
        function <span class="apidocSignatureSpan">yamljs.Utils.</span>isEmptyObject
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmptyObject = function (value) {
  var k;
  return value instanceof Object &#x26;&#x26; ((function() {
    var results;
    results = [];
    for (k in value) {
      if (!hasProp.call(value, k)) continue;
      results.push(k);
    }
    return results;
  })()).length === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.REGEX_RIGHT_TRIM_BY_CHAR[_char] = regexRight = new RegExp(_char + &#x27;&#x27; + _char + &#x27;*$&#x27;);
  }
  regexRight.lastIndex = 0;
  return str.replace(regexRight, &#x27;&#x27;);
};

Utils.isEmpty = function(value) {
  return !value || value === &#x27;&#x27; || value === &#x27;0&#x27; || (value instanceof Array &#x26;&#x26; value.length === 0) ||
this.<span class="apidocCodeKeywordSpan">isEmptyObject</span>(value);
};

Utils.isEmptyObject = function(value) {
  var k;
  return value instanceof Object &#x26;&#x26; ((function() {
    var results;
    results = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Utils.isNumeric" id="apidoc.element.yamljs.Utils.isNumeric">
        function <span class="apidocSignatureSpan">yamljs.Utils.</span>isNumeric
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNumeric = function (input) {
  this.REGEX_SPACES.lastIndex = 0;
  return typeof input === &#x27;number&#x27; || typeof input === &#x27;string&#x27; &#x26;&#x26; !isNaN(input) &#x26;&#x26; input.replace(this.REGEX_SPACES, &#x27;&#x27;) !== &#x27;&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (type === &#x27;boolean&#x27;) {
  return (value ? &#x27;true&#x27; : &#x27;false&#x27;);
}
if (Utils.isDigits(value)) {
  return (type === &#x27;string&#x27; ? &#x22;&#x27;&#x22; + value + &#x22;&#x27;&#x22; : String(parseInt(value)));
}
if (Utils.<span class="apidocCodeKeywordSpan">isNumeric</span>(value)) {
  return (type === &#x27;string&#x27; ? &#x22;&#x27;&#x22; + value + &#x22;&#x27;&#x22; : String(parseFloat(value)));
}
if (type === &#x27;number&#x27;) {
  return (value === 2e308 ? &#x27;.Inf&#x27; : (value === -2e308 ? &#x27;-.Inf&#x27; : (isNaN(value) ? &#x27;.NaN&#x27; : value)));
}
if (Escaper.requiresDoubleQuoting(value)) {
  return Escaper.escapeWithDoubleQuotes(value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Utils.ltrim" id="apidoc.element.yamljs.Utils.ltrim">
        function <span class="apidocSignatureSpan">yamljs.Utils.</span>ltrim
        <span class="apidocSignatureSpan">(str, _char)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ltrim = function (str, _char) {
  var regexLeft;
  if (_char == null) {
    _char = &#x27;\\s&#x27;;
  }
  regexLeft = this.REGEX_LEFT_TRIM_BY_CHAR[_char];
  if (regexLeft == null) {
    this.REGEX_LEFT_TRIM_BY_CHAR[_char] = regexLeft = new RegExp(&#x27;^&#x27; + _char + &#x27;&#x27; + _char + &#x27;*&#x27;);
  }
  regexLeft.lastIndex = 0;
  return str.replace(regexLeft, &#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  };
}
i = context.i;
if (ref = scalar.charAt(i), indexOf.call(stringDelimiters, ref) &#x3e;= 0) {
  output = this.parseQuotedScalar(scalar, context);
  i = context.i;
  if (delimiters != null) {
    tmp = Utils.<span class="apidocCodeKeywordSpan">ltrim</span>(scalar.slice(i), &#x27; &#x27;);
    if (!(ref1 = tmp.charAt(0), indexOf.call(delimiters, ref1) &#x3e;= 0)) {
      throw new ParseException(&#x27;Unexpected characters (&#x27; + scalar.slice(i) + &#x27;).&#x27;);
    }
  }
} else {
  if (!delimiters) {
    output = scalar.slice(i);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Utils.octDec" id="apidoc.element.yamljs.Utils.octDec">
        function <span class="apidocSignatureSpan">yamljs.Utils.</span>octDec
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">octDec = function (input) {
  this.REGEX_OCTAL.lastIndex = 0;
  return parseInt((input + &#x27;&#x27;).replace(this.REGEX_OCTAL, &#x27;&#x27;), 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return null;
  }
  break;
case &#x27;0&#x27;:
  if (&#x27;0x&#x27; === scalar.slice(0, 2)) {
    return Utils.hexDec(scalar);
  } else if (Utils.isDigits(scalar)) {
    return Utils.<span class="apidocCodeKeywordSpan">octDec</span>(scalar);
  } else if (Utils.isNumeric(scalar)) {
    return parseFloat(scalar);
  } else {
    return scalar;
  }
  break;
case &#x27;+&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Utils.parseBoolean" id="apidoc.element.yamljs.Utils.parseBoolean">
        function <span class="apidocSignatureSpan">yamljs.Utils.</span>parseBoolean
        <span class="apidocSignatureSpan">(input, strict)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseBoolean = function (input, strict) {
  var lowerInput;
  if (strict == null) {
    strict = true;
  }
  if (typeof input === &#x27;string&#x27;) {
    lowerInput = input.toLowerCase();
    if (!strict) {
      if (lowerInput === &#x27;no&#x27;) {
        return false;
      }
    }
    if (lowerInput === &#x27;0&#x27;) {
      return false;
    }
    if (lowerInput === &#x27;false&#x27;) {
      return false;
    }
    if (lowerInput === &#x27;&#x27;) {
      return false;
    }
    return true;
  }
  return !!input;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;!str&#x27;:
  return Utils.ltrim(scalar.slice(4));
case &#x27;!!str&#x27;:
  return Utils.ltrim(scalar.slice(5));
case &#x27;!!int&#x27;:
  return parseInt(this.parseScalar(scalar.slice(5)));
case &#x27;!!bool&#x27;:
  return Utils.<span class="apidocCodeKeywordSpan">parseBoolean</span>(this.parseScalar(scalar.slice(6)), false);
case &#x27;!!float&#x27;:
  return parseFloat(this.parseScalar(scalar.slice(7)));
case &#x27;!!timestamp&#x27;:
  return Utils.stringToDate(Utils.ltrim(scalar.slice(11)));
default:
  if (context == null) {
    context = {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Utils.rtrim" id="apidoc.element.yamljs.Utils.rtrim">
        function <span class="apidocSignatureSpan">yamljs.Utils.</span>rtrim
        <span class="apidocSignatureSpan">(str, _char)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rtrim = function (str, _char) {
  var regexRight;
  if (_char == null) {
    _char = &#x27;\\s&#x27;;
  }
  regexRight = this.REGEX_RIGHT_TRIM_BY_CHAR[_char];
  if (regexRight == null) {
    this.REGEX_RIGHT_TRIM_BY_CHAR[_char] = regexRight = new RegExp(_char + &#x27;&#x27; + _char + &#x27;*$&#x27;);
  }
  regexRight.lastIndex = 0;
  return str.replace(regexRight, &#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
} else {
  if (!delimiters) {
    output = scalar.slice(i);
    i += output.length;
    strpos = output.indexOf(&#x27; #&#x27;);
    if (strpos !== -1) {
      output = Utils.<span class="apidocCodeKeywordSpan">rtrim</span>(output.slice(0, strpos));
    }
  } else {
    joinedDelimiters = delimiters.join(&#x27;|&#x27;);
    pattern = this.PATTERN_SCALAR_BY_DELIMITERS[joinedDelimiters];
    if (pattern == null) {
      pattern = new Pattern(&#x27;^(.+?)(&#x27; + joinedDelimiters + &#x27;)&#x27;);
      this.PATTERN_SCALAR_BY_DELIMITERS[joinedDelimiters] = pattern;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Utils.strRepeat" id="apidoc.element.yamljs.Utils.strRepeat">
        function <span class="apidocSignatureSpan">yamljs.Utils.</span>strRepeat
        <span class="apidocSignatureSpan">(str, number)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">strRepeat = function (str, number) {
  var i, res;
  res = &#x27;&#x27;;
  i = 0;
  while (i &#x3c; number) {
    res += str;
    i++;
  }
  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (exceptionOnInvalidType == null) {
  exceptionOnInvalidType = false;
}
if (objectEncoder == null) {
  objectEncoder = null;
}
output = &#x27;&#x27;;
prefix = (indent ? Utils.<span class="apidocCodeKeywordSpan">strRepeat</span>(&#x27; &#x27;, indent) : &#x27;&#x27;);
if (inline &#x3c;= 0 || typeof input !== &#x27;object&#x27; || input instanceof Date || Utils.isEmpty(input)) {
  output += prefix + Inline.dump(input, exceptionOnInvalidType, objectEncoder);
} else {
  if (input instanceof Array) {
    for (i = 0, len = input.length; i &#x3c; len; i++) {
      value = input[i];
      willBeInlined = inline - 1 &#x3c;= 0 || typeof value !== &#x27;object&#x27; || Utils.isEmpty(value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Utils.stringToDate" id="apidoc.element.yamljs.Utils.stringToDate">
        function <span class="apidocSignatureSpan">yamljs.Utils.</span>stringToDate
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringToDate = function (str) {
  var date, day, fraction, hour, info, minute, month, second, tz_hour, tz_minute, tz_offset, year;
  if (!(str != null ? str.length : void 0)) {
    return null;
  }
  info = this.PATTERN_DATE.exec(str);
  if (!info) {
    return null;
  }
  year = parseInt(info.year, 10);
  month = parseInt(info.month, 10) - 1;
  day = parseInt(info.day, 10);
  if (info.hour == null) {
    date = new Date(Date.UTC(year, month, day));
    return date;
  }
  hour = parseInt(info.hour, 10);
  minute = parseInt(info.minute, 10);
  second = parseInt(info.second, 10);
  if (info.fraction != null) {
    fraction = info.fraction.slice(0, 3);
    while (fraction.length &#x3c; 3) {
      fraction += &#x27;0&#x27;;
    }
    fraction = parseInt(fraction, 10);
  } else {
    fraction = 0;
  }
  if (info.tz != null) {
    tz_hour = parseInt(info.tz_hour, 10);
    if (info.tz_minute != null) {
      tz_minute = parseInt(info.tz_minute, 10);
    } else {
      tz_minute = 0;
    }
    tz_offset = (tz_hour * 60 + tz_minute) * 60000;
    if (&#x27;-&#x27; === info.tz_sign) {
      tz_offset *= -1;
    }
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (tz_offset) {
    date.setTime(date.getTime() - tz_offset);
  }
  return date;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;!!int&#x27;:
  return parseInt(this.parseScalar(scalar.slice(5)));
case &#x27;!!bool&#x27;:
  return Utils.parseBoolean(this.parseScalar(scalar.slice(6)), false);
case &#x27;!!float&#x27;:
  return parseFloat(this.parseScalar(scalar.slice(7)));
case &#x27;!!timestamp&#x27;:
  return Utils.<span class="apidocCodeKeywordSpan">stringToDate</span>(Utils.ltrim(scalar.slice(11)));
default:
  if (context == null) {
    context = {
      exceptionOnInvalidType: this.settings.exceptionOnInvalidType,
      objectDecoder: this.settings.objectDecoder,
      i: 0
    };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Utils.subStrCount" id="apidoc.element.yamljs.Utils.subStrCount">
        function <span class="apidocSignatureSpan">yamljs.Utils.</span>subStrCount
        <span class="apidocSignatureSpan">(string, subString, start, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subStrCount = function (string, subString, start, length) {
  var c, i, j, len, ref, sublen;
  c = 0;
  string = &#x27;&#x27; + string;
  subString = &#x27;&#x27; + subString;
  if (start != null) {
    string = string.slice(start);
  }
  if (length != null) {
    string = string.slice(0, length);
  }
  len = string.length;
  sublen = subString.length;
  for (i = j = 0, ref = len; 0 &#x3c;= ref ? j &#x3c; ref : j &#x3e; ref; i = 0 &#x3c;= ref ? ++j : --j) {
    if (subString === string.slice(i, sublen)) {
      c++;
      i += sublen - 1;
    }
  }
  return c;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  value = value.split(&#x22;\r\n&#x22;).join(&#x22;\n&#x22;).split(&#x22;\r&#x22;).join(&#x22;\n&#x22;);
}
count = 0;
ref = this.PATTERN_YAML_HEADER.replaceAll(value, &#x27;&#x27;), value = ref[0], count = ref[1];
this.offset += count;
ref1 = this.PATTERN_LEADING_COMMENTS.replaceAll(value, &#x27;&#x27;, 1), trimmedValue = ref1[0], count = ref1[1];
if (count === 1) {
  this.offset += Utils.<span class="apidocCodeKeywordSpan">subStrCount</span>(value, &#x22;\n&#x22;) - Utils.subStrCount(trimmedValue
, &#x22;\n&#x22;);
  value = trimmedValue;
}
ref2 = this.PATTERN_DOCUMENT_MARKER_START.replaceAll(value, &#x27;&#x27;, 1), trimmedValue = ref2[0], count = ref2[1];
if (count === 1) {
  this.offset += Utils.subStrCount(value, &#x22;\n&#x22;) - Utils.subStrCount(trimmedValue, &#x22;\n&#x22;);
  value = trimmedValue;
  value = this.PATTERN_DOCUMENT_MARKER_END.replace(value, &#x27;&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Utils.trim" id="apidoc.element.yamljs.Utils.trim">
        function <span class="apidocSignatureSpan">yamljs.Utils.</span>trim
        <span class="apidocSignatureSpan">(str, _char)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trim = function (str, _char) {
  var regexLeft, regexRight;
  if (_char == null) {
    _char = &#x27;\\s&#x27;;
  }
  return str.trim();
  regexLeft = this.REGEX_LEFT_TRIM_BY_CHAR[_char];
  if (regexLeft == null) {
    this.REGEX_LEFT_TRIM_BY_CHAR[_char] = regexLeft = new RegExp(&#x27;^&#x27; + _char + &#x27;&#x27; + _char + &#x27;*&#x27;);
  }
  regexLeft.lastIndex = 0;
  regexRight = this.REGEX_RIGHT_TRIM_BY_CHAR[_char];
  if (regexRight == null) {
    this.REGEX_RIGHT_TRIM_BY_CHAR[_char] = regexRight = new RegExp(_char + &#x27;&#x27; + _char + &#x27;*$&#x27;);
  }
  regexRight.lastIndex = 0;
  return str.replace(regexLeft, &#x27;&#x27;).replace(regexRight, &#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  objectDecoder = null;
}
this.settings.exceptionOnInvalidType = exceptionOnInvalidType;
this.settings.objectDecoder = objectDecoder;
if (value == null) {
  return &#x27;&#x27;;
}
value = Utils.<span class="apidocCodeKeywordSpan">trim</span>(value);
if (0 === value.length) {
  return &#x27;&#x27;;
}
context = {
  exceptionOnInvalidType: exceptionOnInvalidType,
  objectDecoder: objectDecoder,
  i: 0
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yamljs.Utils.utf8chr" id="apidoc.element.yamljs.Utils.utf8chr">
        function <span class="apidocSignatureSpan">yamljs.Utils.</span>utf8chr
        <span class="apidocSignatureSpan">(c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utf8chr = function (c) {
  var ch;
  ch = String.fromCharCode;
  if (0x80 &#x3e; (c %= 0x200000)) {
    return ch(c);
  }
  if (0x800 &#x3e; c) {
    return ch(0xC0 | c &#x3e;&#x3e; 6) + ch(0x80 | c &#x26; 0x3F);
  }
  if (0x10000 &#x3e; c) {
    return ch(0xE0 | c &#x3e;&#x3e; 12) + ch(0x80 | c &#x3e;&#x3e; 6 &#x26; 0x3F) + ch(0x80 | c &#x26; 0x3F);
  }
  return ch(0xF0 | c &#x3e;&#x3e; 18) + ch(0x80 | c &#x3e;&#x3e; 12 &#x26; 0x3F) + ch(0x80 | c &#x3e;&#x3e; 6 &#x26; 0x3F) + ch(0x80 | c &#x26; 0x3F);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  case &#x27;_&#x27;:
    return ch(0x00A0);
  case &#x27;L&#x27;:
    return ch(0x2028);
  case &#x27;P&#x27;:
    return ch(0x2029);
  case &#x27;x&#x27;:
    return Utils.<span class="apidocCodeKeywordSpan">utf8chr</span>(Utils.hexDec(value.substr(2, 2)));
  case &#x27;u&#x27;:
    return Utils.utf8chr(Utils.hexDec(value.substr(2, 4)));
  case &#x27;U&#x27;:
    return Utils.utf8chr(Utils.hexDec(value.substr(2, 8)));
  default:
    return &#x27;&#x27;;
}
...</pre></li>
    </ul>


















</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
